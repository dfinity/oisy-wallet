type AddDappSettingsError = variant {
	MaxHiddenDappIds;
	VersionMismatch;
	DappIdTooLong;
	UserNotFound
};
type AddHiddenDappIdRequest = record {
	current_user_version : opt nat64;
	dapp_id : text
};
type AddUserCredentialError = variant {
	InvalidCredential;
	VersionMismatch;
	ConfigurationError;
	UserNotFound
};
type AddUserCredentialRequest = record {
	credential_jwt : text;
	issuer_canister_id : principal;
	current_user_version : opt nat64;
	credential_spec : CredentialSpec
};
type AddUserCredentialResult = variant { Ok; Err : AddUserCredentialError };
type AddUserHiddenDappIdResult = variant { Ok; Err : AddDappSettingsError };
type AllowSigningError = variant {
	ApproveError : ApproveError;
	PowChallenge : ChallengeCompletionError;
	Other : text;
	FailedToContactCyclesLedger
};
type AllowSigningRequest = record { nonce : nat64 };
type AllowSigningResponse = record {
	status : AllowSigningStatus;
	challenge_completion : opt ChallengeCompletion;
	allowed_cycles : nat64
};
type AllowSigningResult = variant {
	Ok : AllowSigningResponse;
	Err : AllowSigningError
};
type AllowSigningStatus = variant { Skipped; Failed; Executed };
type ApproveError = variant {
	GenericError : record { message : text; error_code : nat };
	TemporarilyUnavailable;
	Duplicate : record { duplicate_of : nat };
	BadFee : record { expected_fee : nat };
	AllowanceChanged : record { current_allowance : nat };
	CreatedInFuture : record { ledger_time : nat64 };
	TooOld;
	Expired : record { ledger_time : nat64 };
	InsufficientFunds : record { balance : nat }
};
type Arg = variant { Upgrade; Init : InitArg };
type ArgumentValue = variant { Int : int32; String : text };
type BitcoinNetwork = variant { mainnet; regtest; testnet };
type BtcAddPendingTransactionError = variant {
	InternalError : record { msg : text }
};
type BtcAddPendingTransactionRequest = record {
	txid : blob;
	network : BitcoinNetwork;
	address : text;
	utxos : vec Utxo
};
type BtcAddPendingTransactionResult = variant {
	Ok;
	Err : BtcAddPendingTransactionError
};
type BtcAddress = variant {
	P2WPKH : text;
	P2PKH : text;
	P2WSH : text;
	P2SH : text;
	P2TR : text
};
type BtcGetFeePercentilesRequest = record { network : BitcoinNetwork };
type BtcGetFeePercentilesResponse = record { fee_percentiles : vec nat64 };
type BtcGetFeePercentilesResult = variant {
	Ok : BtcGetFeePercentilesResponse;
	Err : SelectedUtxosFeeError
};
type BtcGetPendingTransactionsReponse = record {
	transactions : vec PendingTransaction
};
type BtcGetPendingTransactionsRequest = record {
	network : BitcoinNetwork;
	address : text
};
type BtcGetPendingTransactionsResult = variant {
	Ok : BtcGetPendingTransactionsReponse;
	Err : BtcAddPendingTransactionError
};
type BtcSelectUserUtxosFeeResult = variant {
	Ok : SelectedUtxosFeeResponse;
	Err : SelectedUtxosFeeError
};
type CanisterStatusResultV2 = record {
	controller : principal;
	status : CanisterStatusType;
	freezing_threshold : nat;
	balance : vec record { blob; nat };
	memory_size : nat;
	cycles : nat;
	settings : DefiniteCanisterSettingsArgs;
	idle_cycles_burned_per_day : nat;
	module_hash : opt blob
};
type CanisterStatusType = variant { stopped; stopping; running };
type ChallengeCompletion = record {
	solved_duration_ms : nat64;
	next_allowance_ms : nat64;
	next_difficulty : nat32;
	current_difficulty : nat32
};
type ChallengeCompletionError = variant {
	InvalidNonce;
	MissingChallenge;
	ExpiredChallenge;
	MissingUserProfile;
	ChallengeAlreadySolved
};
type Config = record {
	derivation_origin : opt text;
	ecdsa_key_name : text;
	cfs_canister_id : opt principal;
	allowed_callers : vec principal;
	supported_credentials : opt vec SupportedCredential;
	ic_root_key_raw : opt blob
};
type Contact = record {
	id : nat64;
	name : text;
	update_timestamp_ns : nat64;
	addresses : vec ContactAddressData;
	image : opt ContactImage
};
type ContactAddressData = record {
	label : opt text;
	token_account_id : TokenAccountId
};
type ContactError = variant {
	InvalidContactData;
	CanisterMemoryNearCapacity;
	InvalidImageFormat;
	ContactNotFound;
	ImageTooLarge;
	RandomnessError;
	ImageExceedsMaxSize;
	CanisterStatusError;
	TooManyContactsWithImages
};
type ContactImage = record { data : blob; mime_type : ImageMimeType };
type CreateChallengeError = variant {
	ChallengeInProgress;
	MissingUserProfile;
	RandomnessError : text;
	Other : text
};
type CreateChallengeResponse = record {
	difficulty : nat32;
	start_timestamp_ms : nat64;
	expiry_timestamp_ms : nat64
};
type CreateContactRequest = record { name : text; image : opt ContactImage };
type CreateContactResult = variant { Ok : Contact; Err : ContactError };
type CreatePowChallengeResult = variant {
	Ok : CreateChallengeResponse;
	Err : CreateChallengeError
};
type CredentialSpec = record {
	arguments : opt vec record { text; ArgumentValue };
	credential_type : text
};
type CredentialType = variant { ProofOfUniqueness };
type CustomToken = record {
	token : Token;
	section : opt TokenSection;
	version : opt nat64;
	enabled : bool
};
type DappCarouselSettings = record { hidden_dapp_ids : vec text };
type DappSettings = record { dapp_carousel : DappCarouselSettings };
type DefiniteCanisterSettingsArgs = record {
	controller : principal;
	freezing_threshold : nat;
	controllers : vec principal;
	memory_allocation : nat;
	compute_allocation : nat
};
type DeleteContactResult = variant { Ok : nat64; Err : ContactError };
type ErcToken = record { token_address : text; chain_id : nat64 };
type EthAddress = variant { Public : text };
type GetAllowedCyclesError = variant {
	Other : text;
	FailedToContactCyclesLedger
};
type GetAllowedCyclesResponse = record { allowed_cycles : nat };
type GetAllowedCyclesResult = variant {
	Ok : GetAllowedCyclesResponse;
	Err : GetAllowedCyclesError
};
type GetContactResult = variant { Ok : Contact; Err : ContactError };
type GetContactsResult = variant { Ok : vec Contact; Err : ContactError };
type GetUserProfileError = variant { NotFound };
type GetUserProfileResult = variant {
	Ok : UserProfile;
	Err : GetUserProfileError
};
type HasUserProfileResponse = record { has_user_profile : bool };
type HttpRequest = record {
	url : text;
	method : text;
	body : blob;
	headers : vec record { text; text }
};
type HttpResponse = record {
	body : blob;
	headers : vec record { text; text };
	status_code : nat16
};
type IcrcToken = record { ledger_id : principal; index_id : opt principal };
type Icrcv2AccountId = variant {
	Account : blob;
	WithPrincipal : record { owner : principal; subaccount : opt blob }
};
type ImageMimeType = variant {
	"image/gif";
	"image/png";
	"image/jpeg";
	"image/webp"
};
type InitArg = record {
	derivation_origin : opt text;
	ecdsa_key_name : text;
	cfs_canister_id : opt principal;
	allowed_callers : vec principal;
	supported_credentials : opt vec SupportedCredential;
	ic_root_key_der : opt blob
};
type NetworkSettings = record { enabled : bool; is_testnet : bool };
type NetworkSettingsFor = variant {
	ArbitrumMainnet;
	InternetComputer;
	BaseSepolia;
	PolygonMainnet;
	BitcoinRegtest;
	SolanaDevnet;
	PolygonAmoy;
	EthereumSepolia;
	BitcoinTestnet;
	BaseMainnet;
	BscMainnet;
	SolanaLocal;
	ArbitrumSepolia;
	EthereumMainnet;
	SolanaMainnet;
	BitcoinMainnet;
	BscTestnet
};
type NetworksSettings = record {
	networks : vec record { NetworkSettingsFor; NetworkSettings };
	testnets : TestnetsSettings
};
type Outpoint = record { txid : blob; vout : nat32 };
type PendingTransaction = record { txid : blob; utxos : vec Utxo };
type SaveNetworksSettingsRequest = record {
	networks : vec record { NetworkSettingsFor; NetworkSettings };
	current_user_version : opt nat64
};
type SaveTestnetsSettingsError = variant { VersionMismatch; UserNotFound };
type SelectedUtxosFeeError = variant {
	PendingTransactions;
	InternalError : record { msg : text }
};
type SelectedUtxosFeeRequest = record {
	network : BitcoinNetwork;
	amount_satoshis : nat64;
	min_confirmations : opt nat32
};
type SelectedUtxosFeeResponse = record {
	fee_satoshis : nat64;
	utxos : vec Utxo
};
type SetShowTestnetsRequest = record {
	current_user_version : opt nat64;
	show_testnets : bool
};
type SetUserShowTestnetsResult = variant {
	Ok;
	Err : SaveTestnetsSettingsError
};
type Settings = record { networks : NetworksSettings; dapp : DappSettings };
type SplToken = record {
	decimals : opt nat8;
	token_address : text;
	symbol : opt text
};
type Stats = record {
	user_profile_count : nat64;
	custom_token_count : nat64;
	user_timestamps_count : nat64;
	user_token_count : nat64
};
type SupportedCredential = record {
	ii_canister_id : principal;
	issuer_origin : text;
	issuer_canister_id : principal;
	ii_origin : text;
	credential_type : CredentialType
};
type TestnetsSettings = record { show_testnets : bool };
type Token = variant {
	Erc20 : ErcToken;
	Icrc : IcrcToken;
	Erc721 : ErcToken;
	SplDevnet : SplToken;
	SplMainnet : SplToken;
	Erc1155 : ErcToken
};
type TokenAccountId = variant {
	Btc : BtcAddress;
	Eth : EthAddress;
	Sol : text;
	Icrcv2 : Icrcv2AccountId
};
type TokenSection = variant { Spam; Hidden };
type TopUpCyclesLedgerError = variant {
	InvalidArgPercentageOutOfRange : record {
		max : nat8;
		min : nat8;
		percentage : nat8
	};
	CouldNotGetBalanceFromCyclesLedger;
	CouldNotTopUpCyclesLedger : record { tried_to_send : nat; available : nat }
};
type TopUpCyclesLedgerRequest = record {
	threshold : opt nat;
	percentage : opt nat8
};
type TopUpCyclesLedgerResponse = record {
	backend_cycles : nat;
	ledger_balance : nat;
	topped_up : nat
};
type TopUpCyclesLedgerResult = variant {
	Ok : TopUpCyclesLedgerResponse;
	Err : TopUpCyclesLedgerError
};
type UserCredential = record {
	issuer : text;
	verified_date_timestamp : opt nat64;
	credential_type : CredentialType
};
type UserProfile = record {
	credentials : vec UserCredential;
	version : opt nat64;
	settings : opt Settings;
	created_timestamp : nat64;
	updated_timestamp : nat64
};
type UserToken = record {
	decimals : opt nat8;
	version : opt nat64;
	enabled : opt bool;
	chain_id : nat64;
	contract_address : text;
	symbol : opt text
};
type UserTokenId = record { chain_id : nat64; contract_address : text };
type Utxo = record { height : nat32; value : nat64; outpoint : Outpoint };
service : (Arg) -> {
	// Adds a verifiable credential to the user profile.
	//
	// # Errors
	// Errors are enumerated by: `AddUserCredentialError`.
	add_user_credential : (AddUserCredentialRequest) -> (AddUserCredentialResult);
	// Adds a dApp ID to the user's list of dApps that are not shown in the carousel.
	//
	// # Arguments
	// * `request` - The request to add a hidden dApp ID.
	//
	// # Returns
	// - Returns `Ok(())` if the dApp ID was added successfully, or if it was already in the list.
	//
	// # Errors
	// - Returns `Err` if the user profile is not found, or the user profile version is not up-to-date.
	add_user_hidden_dapp_id : (AddHiddenDappIdRequest) -> (
		AddUserHiddenDappIdResult
	);
	// This function authorizes the caller to spend a specific
	//
	// Note:
	// - The chain fusion signer performs threshold key operations including providing public keys,
	// creating signatures and assisting with performing signed Bitcoin and Ethereum transactions.
	//
	// # Errors
	// Errors are enumerated by: `AllowSigningError`.
	allow_signing : (opt AllowSigningRequest) -> (AllowSigningResult);
	// Adds a pending Bitcoin transaction for the caller.
	//
	// # Errors
	// Errors are enumerated by: `BtcAddPendingTransactionError`.
	btc_add_pending_transaction : (BtcAddPendingTransactionRequest) -> (
		BtcAddPendingTransactionResult
	);
	// Retrieves the current fee percentiles for Bitcoin transactions from the cache
	// for the specified network. Fee percentiles are measured in millisatoshi per byte
	// and are periodically updated in the background.
	//
	// # Returns
	// - On success: `Ok(BtcGetFeePercentilesResponse)` containing an array of fee percentiles
	// - On failure: `Err(SelectedUtxosFeeError)` indicating what went wrong
	//
	// # Errors
	// - `InternalError`: If fee percentiles are not available in the cache for the requested network
	//
	// # Note
	// This function only returns data from the in-memory cache and doesn't make any calls
	// to the Bitcoin API itself. If the cache doesn't have data for the requested network,
	// an error is returned rather than fetching fresh data.
	btc_get_current_fee_percentiles : (BtcGetFeePercentilesRequest) -> (
		BtcGetFeePercentilesResult
	) query;
	// Returns the pending Bitcoin transactions for the caller.
	//
	// # Errors
	// Errors are enumerated by: `BtcGetPendingTransactionsError`.
	btc_get_pending_transactions : (BtcGetPendingTransactionsRequest) -> (
		BtcGetPendingTransactionsResult
	);
	// Selects the user's UTXOs and calculates the fee for a Bitcoin transaction.
	//
	// # Errors
	// Errors are enumerated by: `SelectedUtxosFeeError`.
	btc_select_user_utxos_fee : (SelectedUtxosFeeRequest) -> (
		BtcSelectUserUtxosFeeResult
	);
	// Gets the canister configuration.
	config : () -> (Config) query;
	// Creates a new contact for the caller.
	//
	// # Errors
	// Errors are enumerated by: `ContactError`.
	//
	// # Returns
	// The created contact on success.
	//
	// # Test
	// This endpoint is currently a placeholder and will be fully implemented in a future PR.
	create_contact : (CreateContactRequest) -> (CreateContactResult);
	// Creates a new proof-of-work challenge for the caller.
	//
	// # Errors
	// Errors are enumerated by: `CreateChallengeError`.
	//
	// # Returns
	//
	// * `Ok(CreateChallengeResponse)` - On successful challenge creation.
	// * `Err(CreateChallengeError)` - If challenge creation fails due to invalid parameters or
	// internal errors.
	create_pow_challenge : () -> (CreatePowChallengeResult);
	// It create a new user profile for the caller.
	// If the user has already a profile, it will return that profile.
	create_user_profile : () -> (UserProfile);
	// Deletes a contact for the caller.
	//
	// # Errors
	// Errors are enumerated by: `ContactError`.
	//
	// # Notes
	// This operation is idempotent - it will return OK if the contact has already been deleted.
	delete_contact : (nat64) -> (DeleteContactResult);
	// Gets account creation timestamps.
	get_account_creation_timestamps : () -> (
		vec record { principal; nat64 }
	) query;
	// Retrieves the amount of cycles that the signer canister is allowed to spend
	// on behalf of the current user
	// # Returns
	// - On success: `Ok(GetAllowedCyclesResponse)` containing the allowance in cycles
	// - On failure: `Err(GetAllowedCyclesError)` indicating what went wrong
	//
	// # Errors
	// - `FailedToContactCyclesLedger`: If the call to the cycles ledger canister failed
	// - `Other`: If another error occurred during the operation
	get_allowed_cycles : () -> (GetAllowedCyclesResult);
	// API method to get cycle balance and burn rate.
	get_canister_status : () -> (CanisterStatusResultV2);
	// Gets a contact by ID for the caller.
	//
	// # Arguments
	// * `contact_id` - The unique identifier of the contact to retrieve
	// # Returns
	// * `Ok(GetContactResult)` - The requested contact if found
	// # Errors
	// * `ContactNotFound` - If no contact for the provided `contact_id` could be found
	get_contact : (nat64) -> (GetContactResult) query;
	// Returns all contacts for the caller
	//
	// This query function returns a list of the user's contacts.
	// # Returns
	// * `Ok(Vec<Contact>)` - A vector of the user's contacts.
	get_contacts : () -> (GetContactsResult) query;
	// Returns the caller's user profile.
	//
	// # Errors
	// Errors are enumerated by: `GetUserProfileError`.
	//
	// # Panics
	// - If the caller is anonymous.  See: `may_read_user_data`.
	get_user_profile : () -> (GetUserProfileResult) query;
	// Checks if the caller has an associated user profile.
	//
	// # Returns
	// - `Ok(true)` if a user profile exists for the caller.
	// - `Ok(false)` if no user profile exists for the caller.
	// # Errors
	// Does not return any error
	has_user_profile : () -> (HasUserProfileResponse) query;
	// Processes external HTTP requests.
	http_request : (HttpRequest) -> (HttpResponse) query;
	list_custom_tokens : () -> (vec CustomToken) query;
	list_user_tokens : () -> (vec UserToken) query;
	// Remove custom token for the user.
	remove_custom_token : (CustomToken) -> ();
	remove_user_token : (UserTokenId) -> ();
	// Add or update custom token for the user.
	set_custom_token : (CustomToken) -> ();
	set_many_custom_tokens : (vec CustomToken) -> ();
	set_many_user_tokens : (vec UserToken) -> ();
	// Sets the user's preference to show (or hide) testnets in the interface.
	//
	// # Returns
	// - Returns `Ok(())` if the testnets setting was saved successfully, or if it was already set to
	// the same value.
	//
	// # Errors
	// - Returns `Err` if the user profile is not found, or the user profile version is not up-to-date.
	set_user_show_testnets : (SetShowTestnetsRequest) -> (
		SetUserShowTestnetsResult
	);
	set_user_token : (UserToken) -> ();
	// Gets statistics about the canister.
	//
	// Note: This is a private method, restricted to authorized users, as some stats may not be
	// suitable for public consumption.
	stats : () -> (Stats) query;
	// Adds cycles to the cycles ledger, if it is below a certain threshold.
	//
	// # Errors
	// Error conditions are enumerated by: `TopUpCyclesLedgerError`
	top_up_cycles_ledger : (opt TopUpCyclesLedgerRequest) -> (
		TopUpCyclesLedgerResult
	);
	// Updates an existing contact for the caller.
	//
	// # Errors
	// Errors are enumerated by: `ContactError`.
	update_contact : (Contact) -> (GetContactResult);
	// Updates the user's preference to enable (or disable) networks in the interface, merging with any
	// existing settings.
	//
	// # Returns
	// - Returns `Ok(())` if the network settings were updated successfully, or if they were already
	// set to the same value.
	//
	// # Errors
	// - Returns `Err` if the user profile is not found, or the user profile version is not up-to-date.
	update_user_network_settings : (SaveNetworksSettingsRequest) -> (
		SetUserShowTestnetsResult
	)
}
