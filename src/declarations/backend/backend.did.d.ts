/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @icp-sdk/bindgen@0.2.0.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import type { ActorMethod } from '@icp-sdk/core/agent';
import type { IDL } from '@icp-sdk/core/candid';
import type { Principal } from '@icp-sdk/core/principal';

export type AddDappSettingsError =
	| { MaxHiddenDappIds: null }
	| { VersionMismatch: null }
	| { DappIdTooLong: null }
	| { UserNotFound: null };
export interface AddHiddenDappIdRequest {
	current_user_version: [] | [bigint];
	dapp_id: string;
}
export type AddUserCredentialError =
	| { InvalidCredential: null }
	| { VersionMismatch: null }
	| { ConfigurationError: null }
	| { UserNotFound: null };
export interface AddUserCredentialRequest {
	credential_jwt: string;
	issuer_canister_id: Principal;
	current_user_version: [] | [bigint];
	credential_spec: CredentialSpec;
}
export type AddUserCredentialResult = { Ok: null } | { Err: AddUserCredentialError };
export type AddUserHiddenDappIdResult = { Ok: null } | { Err: AddDappSettingsError };
export interface Agreements {
	agreements: UserAgreements;
}
export type AllowSigningError =
	| { ApproveError: ApproveError }
	| { PowChallenge: ChallengeCompletionError }
	| { Other: string }
	| { FailedToContactCyclesLedger: null };
export interface AllowSigningRequest {
	nonce: bigint;
}
export interface AllowSigningResponse {
	status: AllowSigningStatus;
	challenge_completion: [] | [ChallengeCompletion];
	allowed_cycles: bigint;
}
export type AllowSigningResult = { Ok: AllowSigningResponse } | { Err: AllowSigningError };
export type AllowSigningStatus = { Skipped: null } | { Failed: null } | { Executed: null };
export type ApproveError =
	| {
			GenericError: { message: string; error_code: bigint };
	  }
	| { TemporarilyUnavailable: null }
	| { Duplicate: { duplicate_of: bigint } }
	| { BadFee: { expected_fee: bigint } }
	| { AllowanceChanged: { current_allowance: bigint } }
	| { CreatedInFuture: { ledger_time: bigint } }
	| { TooOld: null }
	| { Expired: { ledger_time: bigint } }
	| { InsufficientFunds: { balance: bigint } };
export type Arg = { Upgrade: null } | { Init: InitArg };
export type ArgumentValue = { Int: number } | { String: string };
export type BitcoinNetwork = { mainnet: null } | { regtest: null } | { testnet: null };
export type BtcAddPendingTransactionError = {
	InternalError: { msg: string };
};
export interface BtcAddPendingTransactionRequest {
	txid: Uint8Array;
	network: BitcoinNetwork;
	address: string;
	utxos: Array<Utxo>;
}
export type BtcAddPendingTransactionResult = { Ok: null } | { Err: BtcAddPendingTransactionError };
export type BtcAddress =
	| { P2WPKH: string }
	| { P2PKH: string }
	| { P2WSH: string }
	| { P2SH: string }
	| { P2TR: string };
export interface BtcGetFeePercentilesRequest {
	network: BitcoinNetwork;
}
export interface BtcGetFeePercentilesResponse {
	fee_percentiles: BigUint64Array;
}
export type BtcGetFeePercentilesResult =
	| {
			Ok: BtcGetFeePercentilesResponse;
	  }
	| { Err: SelectedUtxosFeeError };
export interface BtcGetPendingTransactionsReponse {
	transactions: Array<PendingTransaction>;
}
export interface BtcGetPendingTransactionsRequest {
	network: BitcoinNetwork;
	address: string;
}
export type BtcGetPendingTransactionsResult =
	| {
			Ok: BtcGetPendingTransactionsReponse;
	  }
	| { Err: BtcAddPendingTransactionError };
export type BtcSelectUserUtxosFeeResult =
	| { Ok: SelectedUtxosFeeResponse }
	| { Err: SelectedUtxosFeeError };
export interface CanisterStatusResultV2 {
	controller: Principal;
	status: CanisterStatusType;
	freezing_threshold: bigint;
	balance: Array<[Uint8Array, bigint]>;
	memory_size: bigint;
	cycles: bigint;
	settings: DefiniteCanisterSettingsArgs;
	idle_cycles_burned_per_day: bigint;
	module_hash: [] | [Uint8Array];
}
export type CanisterStatusType = { stopped: null } | { stopping: null } | { running: null };
export interface ChallengeCompletion {
	solved_duration_ms: bigint;
	next_allowance_ms: bigint;
	next_difficulty: number;
	current_difficulty: number;
}
export type ChallengeCompletionError =
	| { InvalidNonce: null }
	| { MissingChallenge: null }
	| { ExpiredChallenge: null }
	| { MissingUserProfile: null }
	| { ChallengeAlreadySolved: null };
export interface Config {
	derivation_origin: [] | [string];
	ecdsa_key_name: string;
	cfs_canister_id: [] | [Principal];
	allowed_callers: Array<Principal>;
	supported_credentials: [] | [Array<SupportedCredential>];
	ic_root_key_raw: [] | [Uint8Array];
}
export interface Contact {
	id: bigint;
	name: string;
	update_timestamp_ns: bigint;
	addresses: Array<ContactAddressData>;
	image: [] | [ContactImage];
}
export interface ContactAddressData {
	label: [] | [string];
	token_account_id: TokenAccountId;
}
export type ContactError =
	| { InvalidContactData: null }
	| { CanisterMemoryNearCapacity: null }
	| { InvalidImageFormat: null }
	| { ContactNotFound: null }
	| { ImageTooLarge: null }
	| { RandomnessError: null }
	| { ImageExceedsMaxSize: null }
	| { CanisterStatusError: null }
	| { TooManyContactsWithImages: null };
export interface ContactImage {
	data: Uint8Array;
	mime_type: ImageMimeType;
}
export type CreateChallengeError =
	| { ChallengeInProgress: null }
	| { MissingUserProfile: null }
	| { RandomnessError: string }
	| { Other: string };
export interface CreateChallengeResponse {
	difficulty: number;
	start_timestamp_ms: bigint;
	expiry_timestamp_ms: bigint;
}
export interface CreateContactRequest {
	name: string;
	image: [] | [ContactImage];
}
export type CreateContactResult = { Ok: Contact } | { Err: ContactError };
export type CreatePowChallengeResult =
	| { Ok: CreateChallengeResponse }
	| { Err: CreateChallengeError };
export interface CredentialSpec {
	arguments: [] | [Array<[string, ArgumentValue]>];
	credential_type: string;
}
export type CredentialType = { ProofOfUniqueness: null };
export interface CustomToken {
	token: Token;
	allow_external_content_source: [] | [boolean];
	section: [] | [TokenSection];
	version: [] | [bigint];
	enabled: boolean;
}
export interface DappCarouselSettings {
	hidden_dapp_ids: Array<string>;
}
export interface DappSettings {
	dapp_carousel: DappCarouselSettings;
}
export interface DefiniteCanisterSettingsArgs {
	controller: Principal;
	freezing_threshold: bigint;
	controllers: Array<Principal>;
	memory_allocation: bigint;
	compute_allocation: bigint;
}
export type DeleteContactResult = { Ok: bigint } | { Err: ContactError };
export interface ErcToken {
	token_address: string;
	chain_id: bigint;
}
export type EthAddress = { Public: string };
export interface ExperimentalFeatureSettings {
	enabled: boolean;
}
export type ExperimentalFeatureSettingsFor = { AiAssistantBeta: null };
export interface ExperimentalFeaturesSettings {
	experimental_features: Array<[ExperimentalFeatureSettingsFor, ExperimentalFeatureSettings]>;
}
export interface ExtV2Token {
	canister_id: Principal;
}
export type GetAllowedCyclesError = { Other: string } | { FailedToContactCyclesLedger: null };
export interface GetAllowedCyclesResponse {
	allowed_cycles: bigint;
}
export type GetAllowedCyclesResult =
	| { Ok: GetAllowedCyclesResponse }
	| { Err: GetAllowedCyclesError };
export type GetContactResult = { Ok: Contact } | { Err: ContactError };
export type GetContactsResult = { Ok: Array<Contact> } | { Err: ContactError };
export type GetUserProfileError = { NotFound: null };
export type GetUserProfileResult = { Ok: UserProfile } | { Err: GetUserProfileError };
export interface HasUserProfileResponse {
	has_user_profile: boolean;
}
export interface HttpRequest {
	url: string;
	method: string;
	body: Uint8Array;
	headers: Array<[string, string]>;
}
export interface HttpResponse {
	body: Uint8Array;
	headers: Array<[string, string]>;
	status_code: number;
}
export interface IcrcToken {
	ledger_id: Principal;
	index_id: [] | [Principal];
}
export type Icrcv2AccountId =
	| { Account: Uint8Array }
	| {
			WithPrincipal: { owner: Principal; subaccount: [] | [Uint8Array] };
	  };
export type ImageMimeType =
	| { 'image/gif': null }
	| { 'image/png': null }
	| { 'image/jpeg': null }
	| { 'image/webp': null };
export interface InitArg {
	derivation_origin: [] | [string];
	ecdsa_key_name: string;
	cfs_canister_id: [] | [Principal];
	allowed_callers: Array<Principal>;
	supported_credentials: [] | [Array<SupportedCredential>];
	ic_root_key_der: [] | [Uint8Array];
}
export interface NetworkSettings {
	enabled: boolean;
	is_testnet: boolean;
}
export type NetworkSettingsFor =
	| { ArbitrumMainnet: null }
	| { InternetComputer: null }
	| { BaseSepolia: null }
	| { PolygonMainnet: null }
	| { BitcoinRegtest: null }
	| { SolanaDevnet: null }
	| { PolygonAmoy: null }
	| { EthereumSepolia: null }
	| { BitcoinTestnet: null }
	| { BaseMainnet: null }
	| { BscMainnet: null }
	| { SolanaLocal: null }
	| { ArbitrumSepolia: null }
	| { EthereumMainnet: null }
	| { SolanaMainnet: null }
	| { BitcoinMainnet: null }
	| { BscTestnet: null };
export interface NetworksSettings {
	networks: Array<[NetworkSettingsFor, NetworkSettings]>;
	testnets: TestnetsSettings;
}
export interface Outpoint {
	txid: Uint8Array;
	vout: number;
}
export interface PendingTransaction {
	txid: Uint8Array;
	utxos: Array<Utxo>;
}
export interface SaveNetworksSettingsRequest {
	networks: Array<[NetworkSettingsFor, NetworkSettings]>;
	current_user_version: [] | [bigint];
}
export type SelectedUtxosFeeError =
	| { PendingTransactions: null }
	| { InternalError: { msg: string } };
export interface SelectedUtxosFeeRequest {
	network: BitcoinNetwork;
	amount_satoshis: bigint;
	min_confirmations: [] | [number];
}
export interface SelectedUtxosFeeResponse {
	fee_satoshis: bigint;
	utxos: Array<Utxo>;
}
export interface SetShowTestnetsRequest {
	current_user_version: [] | [bigint];
	show_testnets: boolean;
}
export type SetTestnetsSettingsError = { VersionMismatch: null } | { UserNotFound: null };
export type SetUserShowTestnetsResult = { Ok: null } | { Err: UpdateAgreementsError };
export interface Settings {
	networks: NetworksSettings;
	dapp: DappSettings;
	experimental_features: ExperimentalFeaturesSettings;
}
export interface SplToken {
	decimals: [] | [number];
	token_address: string;
	symbol: [] | [string];
}
export interface Stats {
	user_profile_count: bigint;
	custom_token_count: bigint;
	user_timestamps_count: bigint;
	user_token_count: bigint;
}
export interface SupportedCredential {
	ii_canister_id: Principal;
	issuer_origin: string;
	issuer_canister_id: Principal;
	ii_origin: string;
	credential_type: CredentialType;
}
export interface TestnetsSettings {
	show_testnets: boolean;
}
export type Token =
	| { Erc20: ErcToken }
	| { ExtV2: ExtV2Token }
	| { Icrc: IcrcToken }
	| { Erc721: ErcToken }
	| { SplDevnet: SplToken }
	| { SplMainnet: SplToken }
	| { IcPunks: ExtV2Token }
	| { Erc1155: ErcToken }
	| { Dip721: ExtV2Token };
export type TokenAccountId =
	| { Btc: BtcAddress }
	| { Eth: EthAddress }
	| { Sol: string }
	| { Icrcv2: Icrcv2AccountId };
export type TokenSection = { Spam: null } | { Hidden: null };
export type TopUpCyclesLedgerError =
	| {
			InvalidArgPercentageOutOfRange: {
				max: number;
				min: number;
				percentage: number;
			};
	  }
	| { CouldNotGetBalanceFromCyclesLedger: null }
	| {
			CouldNotTopUpCyclesLedger: {
				tried_to_send: bigint;
				available: bigint;
			};
	  };
export interface TopUpCyclesLedgerRequest {
	threshold: [] | [bigint];
	percentage: [] | [number];
}
export interface TopUpCyclesLedgerResponse {
	backend_cycles: bigint;
	ledger_balance: bigint;
	topped_up: bigint;
}
export type TopUpCyclesLedgerResult =
	| { Ok: TopUpCyclesLedgerResponse }
	| { Err: TopUpCyclesLedgerError };
export type UpdateAgreementsError = { VersionMismatch: null } | { UserNotFound: null };
export interface UpdateExperimentalFeaturesSettingsRequest {
	experimental_features: Array<[ExperimentalFeatureSettingsFor, ExperimentalFeatureSettings]>;
	current_user_version: [] | [bigint];
}
export interface UpdateUserAgreementsRequest {
	agreements: UserAgreements;
	current_user_version: [] | [bigint];
}
export interface UserAgreement {
	last_accepted_at_ns: [] | [bigint];
	text_sha256: [] | [string];
	accepted: [] | [boolean];
	last_updated_at_ms: [] | [bigint];
}
export interface UserAgreements {
	license_agreement: UserAgreement;
	privacy_policy: UserAgreement;
	terms_of_use: UserAgreement;
}
export interface UserCredential {
	issuer: string;
	verified_date_timestamp: [] | [bigint];
	credential_type: CredentialType;
}
export interface UserProfile {
	agreements: [] | [Agreements];
	credentials: Array<UserCredential>;
	version: [] | [bigint];
	settings: [] | [Settings];
	created_timestamp: bigint;
	updated_timestamp: bigint;
}
export interface Utxo {
	height: number;
	value: bigint;
	outpoint: Outpoint;
}
export interface _SERVICE {
	/**
	 * Adds a verifiable credential to the user profile.
	 *
	 * # Errors
	 * Errors are enumerated by: `AddUserCredentialError`.
	 */
	add_user_credential: ActorMethod<[AddUserCredentialRequest], AddUserCredentialResult>;
	/**
	 * Adds a dApp ID to the user's list of dApps that are not shown in the carousel.
	 *
	 * # Arguments
	 * * `request` - The request to add a hidden dApp ID.
	 *
	 * # Returns
	 * - Returns `Ok(())` if the dApp ID was added successfully, or if it was already in the list.
	 *
	 * # Errors
	 * - Returns `Err` if the user profile is not found, or the user profile version is not up-to-date.
	 */
	add_user_hidden_dapp_id: ActorMethod<[AddHiddenDappIdRequest], AddUserHiddenDappIdResult>;
	/**
	 * This function authorizes the caller to spend a specific
	 *
	 * Note:
	 * - The chain fusion signer performs threshold key operations including providing public keys,
	 * creating signatures and assisting with performing signed Bitcoin and Ethereum transactions.
	 *
	 * # Errors
	 * Errors are enumerated by: `AllowSigningError`.
	 */
	allow_signing: ActorMethod<[[] | [AllowSigningRequest]], AllowSigningResult>;
	/**
	 * Adds a pending Bitcoin transaction for the caller.
	 *
	 * # Errors
	 * Errors are enumerated by: `BtcAddPendingTransactionError`.
	 */
	btc_add_pending_transaction: ActorMethod<
		[BtcAddPendingTransactionRequest],
		BtcAddPendingTransactionResult
	>;
	/**
	 * Retrieves the current fee percentiles for Bitcoin transactions from the cache
	 * for the specified network. Fee percentiles are measured in millisatoshi per byte
	 * and are periodically updated in the background.
	 *
	 * # Returns
	 * - On success: `Ok(BtcGetFeePercentilesResponse)` containing an array of fee percentiles
	 * - On failure: `Err(SelectedUtxosFeeError)` indicating what went wrong
	 *
	 * # Errors
	 * - `InternalError`: If fee percentiles are not available in the cache for the requested network
	 *
	 * # Note
	 * This function only returns data from the in-memory cache and doesn't make any calls
	 * to the Bitcoin API itself. If the cache doesn't have data for the requested network,
	 * an error is returned rather than fetching fresh data.
	 */
	btc_get_current_fee_percentiles: ActorMethod<
		[BtcGetFeePercentilesRequest],
		BtcGetFeePercentilesResult
	>;
	/**
	 * Returns the pending Bitcoin transactions for the caller.
	 *
	 * # Errors
	 * Errors are enumerated by: `BtcGetPendingTransactionsError`.
	 */
	btc_get_pending_transactions: ActorMethod<
		[BtcGetPendingTransactionsRequest],
		BtcGetPendingTransactionsResult
	>;
	/**
	 * Selects the user's UTXOs and calculates the fee for a Bitcoin transaction.
	 *
	 * # Errors
	 * Errors are enumerated by: `SelectedUtxosFeeError`.
	 */
	btc_select_user_utxos_fee: ActorMethod<[SelectedUtxosFeeRequest], BtcSelectUserUtxosFeeResult>;
	/**
	 * Gets the canister configuration.
	 */
	config: ActorMethod<[], Config>;
	/**
	 * Creates a new contact for the caller.
	 *
	 * # Errors
	 * Errors are enumerated by: `ContactError`.
	 *
	 * # Returns
	 * The created contact on success.
	 *
	 * # Test
	 * This endpoint is currently a placeholder and will be fully implemented in a future PR.
	 */
	create_contact: ActorMethod<[CreateContactRequest], CreateContactResult>;
	/**
	 * Creates a new proof-of-work challenge for the caller.
	 *
	 * # Errors
	 * Errors are enumerated by: `CreateChallengeError`.
	 *
	 * # Returns
	 *
	 * * `Ok(CreateChallengeResponse)` - On successful challenge creation.
	 * * `Err(CreateChallengeError)` - If challenge creation fails due to invalid parameters or
	 * internal errors.
	 */
	create_pow_challenge: ActorMethod<[], CreatePowChallengeResult>;
	/**
	 * It creates a new user profile for the caller.
	 * If the user has already a profile, it will return that profile.
	 */
	create_user_profile: ActorMethod<[], UserProfile>;
	/**
	 * Deletes a contact for the caller.
	 *
	 * # Errors
	 * Errors are enumerated by: `ContactError`.
	 *
	 * # Notes
	 * This operation is idempotent - it will return OK if the contact has already been deleted.
	 */
	delete_contact: ActorMethod<[bigint], DeleteContactResult>;
	/**
	 * Gets account creation timestamps.
	 */
	get_account_creation_timestamps: ActorMethod<[], Array<[Principal, bigint]>>;
	/**
	 * Retrieves the amount of cycles that the signer canister is allowed to spend
	 * on behalf of the current user
	 * # Returns
	 * - On success: `Ok(GetAllowedCyclesResponse)` containing the allowance in cycles
	 * - On failure: `Err(GetAllowedCyclesError)` indicating what went wrong
	 *
	 * # Errors
	 * - `FailedToContactCyclesLedger`: If the call to the cycles ledger canister failed
	 * - `Other`: If another error occurred during the operation
	 */
	get_allowed_cycles: ActorMethod<[], GetAllowedCyclesResult>;
	/**
	 * API method to get cycle balance and burn rate.
	 */
	get_canister_status: ActorMethod<[], CanisterStatusResultV2>;
	/**
	 * Gets a contact by ID for the caller.
	 *
	 * # Arguments
	 * * `contact_id` - The unique identifier of the contact to retrieve
	 * # Returns
	 * * `Ok(GetContactResult)` - The requested contact if found
	 * # Errors
	 * * `ContactNotFound` - If no contact for the provided `contact_id` could be found
	 */
	get_contact: ActorMethod<[bigint], GetContactResult>;
	/**
	 * Returns all contacts for the caller
	 *
	 * This query function returns a list of the user's contacts.
	 * # Returns
	 * * `Ok(Vec<Contact>)` - A vector of the user's contacts.
	 */
	get_contacts: ActorMethod<[], GetContactsResult>;
	/**
	 * Returns the caller's user profile.
	 *
	 * # Errors
	 * Errors are enumerated by: `GetUserProfileError`.
	 *
	 * # Panics
	 * - If the caller is anonymous.  See: `may_read_user_data`.
	 */
	get_user_profile: ActorMethod<[], GetUserProfileResult>;
	/**
	 * Checks if the caller has an associated user profile.
	 *
	 * # Returns
	 * - `Ok(true)` if a user profile exists for the caller.
	 * - `Ok(false)` if no user profile exists for the caller.
	 * # Errors
	 * Does not return any error
	 */
	has_user_profile: ActorMethod<[], HasUserProfileResponse>;
	/**
	 * Processes external HTTP requests.
	 */
	http_request: ActorMethod<[HttpRequest], HttpResponse>;
	list_custom_tokens: ActorMethod<[], Array<CustomToken>>;
	/**
	 * Remove custom token for the user.
	 */
	remove_custom_token: ActorMethod<[CustomToken], undefined>;
	/**
	 * Add or update custom token for the user.
	 */
	set_custom_token: ActorMethod<[CustomToken], undefined>;
	set_many_custom_tokens: ActorMethod<[Array<CustomToken>], undefined>;
	/**
	 * Sets the user's preference to show (or hide) testnets in the interface.
	 *
	 * # Returns
	 * - Returns `Ok(())` if the testnets setting was saved successfully, or if it was already set to
	 * the same value.
	 *
	 * # Errors
	 * - Returns `Err` if the user profile is not found, or the user profile version is not up-to-date.
	 */
	set_user_show_testnets: ActorMethod<[SetShowTestnetsRequest], SetUserShowTestnetsResult>;
	/**
	 * Gets statistics about the canister.
	 *
	 * Note: This is a private method, restricted to authorized users, as some stats may not be
	 * suitable for public consumption.
	 */
	stats: ActorMethod<[], Stats>;
	/**
	 * Adds cycles to the cycles ledger, if it is below a certain threshold.
	 *
	 * # Errors
	 * Error conditions are enumerated by: `TopUpCyclesLedgerError`
	 */
	top_up_cycles_ledger: ActorMethod<[[] | [TopUpCyclesLedgerRequest]], TopUpCyclesLedgerResult>;
	/**
	 * Updates an existing contact for the caller.
	 *
	 * # Errors
	 * Errors are enumerated by: `ContactError`.
	 */
	update_contact: ActorMethod<[Contact], GetContactResult>;
	/**
	 * Updates the user's agreements, merging with any existing ones.
	 * Only fields where `accepted` is `Some(_)` are applied. If `Some(true)`, `last_accepted_at_ns` is
	 * set to `now`.
	 *
	 * # Returns
	 * - Returns `Ok(())` if the agreements were saved successfully, or if they were already set to the
	 * same value.
	 *
	 * # Errors
	 * - Returns `Err` if the user profile is not found, or the user profile version is not up-to-date.
	 */
	update_user_agreements: ActorMethod<[UpdateUserAgreementsRequest], SetUserShowTestnetsResult>;
	/**
	 * Updates the user's preference to enable (or disable) experimental features in the interface,
	 * merging with any existing entries.
	 *
	 * # Returns
	 * - Returns `Ok(())` if the experimental features were updated successfully, or if they were
	 * already set to the same value.
	 *
	 * # Errors
	 * - Returns `Err` if the user profile is not found, or the user profile version is not up-to-date.
	 */
	update_user_experimental_feature_settings: ActorMethod<
		[UpdateExperimentalFeaturesSettingsRequest],
		SetUserShowTestnetsResult
	>;
	/**
	 * Updates the user's preference to enable (or disable) networks in the interface, merging with any
	 * existing settings.
	 *
	 * # Returns
	 * - Returns `Ok(())` if the network settings were updated successfully, or if they were already
	 * set to the same value.
	 *
	 * # Errors
	 * - Returns `Err` if the user profile is not found, or the user profile version is not up-to-date.
	 */
	update_user_network_settings: ActorMethod<
		[SaveNetworksSettingsRequest],
		SetUserShowTestnetsResult
	>;
}
export declare const idlFactory: IDL.InterfaceFactory;
export declare const init: (args: { IDL: typeof IDL }) => IDL.Type[];
