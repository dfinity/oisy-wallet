/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @icp-sdk/bindgen@0.1.2.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import type { ActorMethod } from '@icp-sdk/core/agent';
import type { IDL } from '@icp-sdk/core/candid';
import type { Principal } from '@icp-sdk/core/principal';

export type AssetCanisterArgs = { Upgrade: UpgradeArgs } | { Init: InitArgs };
export type BatchId = bigint;
export type BatchOperationKind =
	| {
			SetAssetProperties: SetAssetPropertiesArguments;
	  }
	| { CreateAsset: CreateAssetArguments }
	| { UnsetAssetContent: UnsetAssetContentArguments }
	| { DeleteAsset: DeleteAssetArguments }
	| { SetAssetContent: SetAssetContentArguments }
	| { Clear: ClearArguments };
export type ChunkId = bigint;
/**
 * Reset everything
 */
export type ClearArguments = {};
export interface CommitBatchArguments {
	batch_id: BatchId;
	operations: Array<BatchOperationKind>;
}
export interface CommitProposedBatchArguments {
	batch_id: BatchId;
	evidence: Uint8Array;
}
export interface ComputeEvidenceArguments {
	batch_id: BatchId;
	max_iterations: [] | [number];
}
export interface ConfigurationResponse {
	max_batches: [] | [bigint];
	max_bytes: [] | [bigint];
	max_chunks: [] | [bigint];
}
export interface ConfigureArguments {
	max_batches: [] | [[] | [bigint]];
	max_bytes: [] | [[] | [bigint]];
	max_chunks: [] | [[] | [bigint]];
}
export interface CreateAssetArguments {
	key: Key;
	content_type: string;
	headers: [] | [Array<HeaderField>];
	allow_raw_access: [] | [boolean];
	max_age: [] | [bigint];
	enable_aliasing: [] | [boolean];
}
/**
 * Delete an asset
 */
export interface DeleteAssetArguments {
	key: Key;
}
export interface DeleteBatchArguments {
	batch_id: BatchId;
}
export interface GrantPermission {
	permission: Permission;
	to_principal: Principal;
}
export type HeaderField = [string, string];
export interface HttpRequest {
	url: string;
	method: string;
	body: Uint8Array;
	headers: Array<HeaderField>;
	certificate_version: [] | [number];
}
export interface HttpResponse {
	body: Uint8Array;
	headers: Array<HeaderField>;
	streaming_strategy: [] | [StreamingStrategy];
	status_code: number;
}
export type InitArgs = {};
export type Key = string;
export interface ListPermitted {
	permission: Permission;
}
export type Permission = { Prepare: null } | { ManagePermissions: null } | { Commit: null };
export interface RevokePermission {
	permission: Permission;
	of_principal: Principal;
}
/**
 * Add or change content for an asset, by content encoding
 */
export interface SetAssetContentArguments {
	key: Key;
	sha256: [] | [Uint8Array];
	chunk_ids: Array<ChunkId>;
	content_encoding: string;
}
export interface SetAssetPropertiesArguments {
	key: Key;
	headers: [] | [[] | [Array<HeaderField>]];
	is_aliased: [] | [[] | [boolean]];
	allow_raw_access: [] | [[] | [boolean]];
	max_age: [] | [[] | [bigint]];
}
/**
 * / Sets the list of principals granted each permission.
 */
export interface SetPermissions {
	prepare: Array<Principal>;
	commit: Array<Principal>;
	manage_permissions: Array<Principal>;
}
export interface StreamingCallbackHttpResponse {
	token: [] | [StreamingCallbackToken];
	body: Uint8Array;
}
export interface StreamingCallbackToken {
	key: Key;
	sha256: [] | [Uint8Array];
	index: bigint;
	content_encoding: string;
}
export type StreamingStrategy = {
	Callback: {
		token: StreamingCallbackToken;
		callback: [Principal, string];
	};
};
export type Time = bigint;
/**
 * Remove content for an asset, by content encoding
 */
export interface UnsetAssetContentArguments {
	key: Key;
	content_encoding: string;
}
export interface UpgradeArgs {
	set_permissions: [] | [SetPermissions];
}
export type ValidationResult = { Ok: string } | { Err: string };
export interface _SERVICE {
	api_version: ActorMethod<[], number>;
	authorize: ActorMethod<[Principal], undefined>;
	certified_tree: ActorMethod<[{}], { certificate: Uint8Array; tree: Uint8Array }>;
	clear: ActorMethod<[ClearArguments], undefined>;
	/**
	 * Perform all operations successfully, or reject
	 */
	commit_batch: ActorMethod<[CommitBatchArguments], undefined>;
	/**
	 * Given a batch already proposed, perform all operations successfully, or reject
	 */
	commit_proposed_batch: ActorMethod<[CommitProposedBatchArguments], undefined>;
	/**
	 * Compute a hash over the CommitBatchArguments.  Call until it returns Some(evidence).
	 */
	compute_evidence: ActorMethod<[ComputeEvidenceArguments], [] | [Uint8Array]>;
	configure: ActorMethod<[ConfigureArguments], undefined>;
	create_asset: ActorMethod<[CreateAssetArguments], undefined>;
	create_batch: ActorMethod<[{}], { batch_id: BatchId }>;
	create_chunk: ActorMethod<[{ content: Uint8Array; batch_id: BatchId }], { chunk_id: ChunkId }>;
	deauthorize: ActorMethod<[Principal], undefined>;
	delete_asset: ActorMethod<[DeleteAssetArguments], undefined>;
	/**
	 * Delete a batch that has been created, or proposed for commit, but not yet committed
	 */
	delete_batch: ActorMethod<[DeleteBatchArguments], undefined>;
	get: ActorMethod<
		[{ key: Key; accept_encodings: Array<string> }],
		{
			content: Uint8Array;
			sha256: [] | [Uint8Array];
			content_type: string;
			content_encoding: string;
			total_length: bigint;
		}
	>;
	get_asset_properties: ActorMethod<
		[Key],
		{
			headers: [] | [Array<HeaderField>];
			is_aliased: [] | [boolean];
			allow_raw_access: [] | [boolean];
			max_age: [] | [bigint];
		}
	>;
	/**
	 * if get() returned chunks > 1, call this to retrieve them.
	 * chunks may or may not be split up at the same boundaries as presented to create_chunk().
	 */
	get_chunk: ActorMethod<
		[
			{
				key: Key;
				sha256: [] | [Uint8Array];
				index: bigint;
				content_encoding: string;
			}
		],
		{ content: Uint8Array }
	>;
	get_configuration: ActorMethod<[], ConfigurationResponse>;
	grant_permission: ActorMethod<[GrantPermission], undefined>;
	http_request: ActorMethod<[HttpRequest], HttpResponse>;
	http_request_streaming_callback: ActorMethod<
		[StreamingCallbackToken],
		[] | [StreamingCallbackHttpResponse]
	>;
	list: ActorMethod<
		[{}],
		Array<{
			key: Key;
			encodings: Array<{
				modified: Time;
				sha256: [] | [Uint8Array];
				length: bigint;
				content_encoding: string;
			}>;
			content_type: string;
		}>
	>;
	list_authorized: ActorMethod<[], Array<Principal>>;
	list_permitted: ActorMethod<[ListPermitted], Array<Principal>>;
	/**
	 * Save the batch operations for later commit
	 */
	propose_commit_batch: ActorMethod<[CommitBatchArguments], undefined>;
	revoke_permission: ActorMethod<[RevokePermission], undefined>;
	set_asset_content: ActorMethod<[SetAssetContentArguments], undefined>;
	set_asset_properties: ActorMethod<[SetAssetPropertiesArguments], undefined>;
	/**
	 * Single call to create an asset with content for a single content encoding that
	 * fits within the message ingress limit.
	 */
	store: ActorMethod<
		[
			{
				key: Key;
				content: Uint8Array;
				sha256: [] | [Uint8Array];
				content_type: string;
				content_encoding: string;
			}
		],
		undefined
	>;
	take_ownership: ActorMethod<[], undefined>;
	unset_asset_content: ActorMethod<[UnsetAssetContentArguments], undefined>;
	validate_commit_proposed_batch: ActorMethod<[CommitProposedBatchArguments], ValidationResult>;
	validate_configure: ActorMethod<[ConfigureArguments], ValidationResult>;
	validate_grant_permission: ActorMethod<[GrantPermission], ValidationResult>;
	validate_revoke_permission: ActorMethod<[RevokePermission], ValidationResult>;
	validate_take_ownership: ActorMethod<[], ValidationResult>;
}
export declare const idlService: IDL.ServiceClass;
export declare const idlInitArgs: IDL.Type[];
export declare const idlFactory: IDL.InterfaceFactory;
export declare const init: (args: { IDL: typeof IDL }) => IDL.Type[];
