/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @icp-sdk/bindgen@0.1.2.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import {
	Actor,
	HttpAgent,
	type ActorConfig,
	type ActorSubclass,
	type Agent,
	type HttpAgentOptions
} from '@icp-sdk/core/agent';
import type { Principal } from '@icp-sdk/core/principal';
import { idlFactory, type _SERVICE } from './declarations/xtc_ledger.did';
import type {
	BurnError as _BurnError,
	BurnResult as _BurnResult,
	CreateResult as _CreateResult,
	Event as _Event,
	EventDetail as _EventDetail,
	EventsConnection as _EventsConnection,
	MintError as _MintError,
	MintResult as _MintResult,
	Operation as _Operation,
	ResultCall as _ResultCall,
	ResultSend as _ResultSend,
	Time as _Time,
	TransactionId as _TransactionId,
	TransactionStatus as _TransactionStatus,
	TxError as _TxError,
	TxReceipt as _TxReceipt,
	TxReceiptLegacy as _TxReceiptLegacy,
	TxRecord as _TxRecord
} from './declarations/xtc_ledger.did.d.ts';
export interface Some<T> {
	__kind__: 'Some';
	value: T;
}
export interface None {
	__kind__: 'None';
}
export type Option<T> = Some<T> | None;
function some<T>(value: T): Some<T> {
	return {
		__kind__: 'Some',
		value: value
	};
}
function none(): None {
	return {
		__kind__: 'None'
	};
}
function isNone<T>(option: Option<T>): option is None {
	return option.__kind__ === 'None';
}
function isSome<T>(option: Option<T>): option is Some<T> {
	return option.__kind__ === 'Some';
}
function unwrap<T>(option: Option<T>): T {
	if (isNone(option)) {
		throw new Error('unwrap: none');
	}
	return option.value;
}
function candid_some<T>(value: T): [T] {
	return [value];
}
function candid_none<T>(): [] {
	return [];
}
function record_opt_to_undefined<T>(arg: T | null): T | undefined {
	return arg == null ? undefined : arg;
}
export type Time = bigint;
export interface Event {
	fee: bigint;
	status: TransactionStatus;
	kind: EventDetail;
	cycles: bigint;
	timestamp: bigint;
}
export interface Stats {
	fee: bigint;
	/**
	 * Usage statistics
	 */
	transfers_count: bigint;
	balance: bigint;
	mints_count: bigint;
	transfers_from_count: bigint;
	canisters_created_count: bigint;
	supply: bigint;
	burns_count: bigint;
	approvals_count: bigint;
	proxy_calls_count: bigint;
	history_events: bigint;
}
export type MintResult =
	| {
			__kind__: 'Ok';
			Ok: TransactionId;
	  }
	| {
			__kind__: 'Err';
			Err: MintError;
	  };
export interface EventsConnection {
	data: Array<Event>;
	next_offset: TransactionId;
	next_canister_id?: Principal;
}
export type CreateResult =
	| {
			__kind__: 'Ok';
			Ok: {
				canister_id: Principal;
			};
	  }
	| {
			__kind__: 'Err';
			Err: string;
	  };
export interface Metadata {
	fee: bigint;
	decimals: number;
	owner: Principal;
	logo: string;
	name: string;
	totalSupply: bigint;
	symbol: string;
}
export type TransactionId = bigint;
export type TxReceipt =
	| {
			__kind__: 'Ok';
			Ok: bigint;
	  }
	| {
			__kind__: 'Err';
			Err: TxError;
	  };
export type BurnResult =
	| {
			__kind__: 'Ok';
			Ok: TransactionId;
	  }
	| {
			__kind__: 'Err';
			Err: BurnError;
	  };
export type EventDetail =
	| {
			__kind__: 'Approve';
			Approve: {
				to: Principal;
				from: Principal;
			};
	  }
	| {
			__kind__: 'Burn';
			Burn: {
				to: Principal;
				from: Principal;
			};
	  }
	| {
			__kind__: 'Mint';
			Mint: {
				to: Principal;
			};
	  }
	| {
			__kind__: 'CanisterCreated';
			CanisterCreated: {
				from: Principal;
				canister: Principal;
			};
	  }
	| {
			__kind__: 'CanisterCalled';
			CanisterCalled: {
				from: Principal;
				method_name: string;
				canister: Principal;
			};
	  }
	| {
			__kind__: 'Transfer';
			Transfer: {
				to: Principal;
				from: Principal;
			};
	  }
	| {
			__kind__: 'TransferFrom';
			TransferFrom: {
				to: Principal;
				from: Principal;
				caller: Principal;
			};
	  };
export type ResultSend =
	| {
			__kind__: 'Ok';
			Ok: null;
	  }
	| {
			__kind__: 'Err';
			Err: string;
	  };
export interface TxRecord {
	op: Operation;
	to: Principal;
	fee: bigint;
	status: TransactionStatus;
	from: Principal;
	timestamp: Time;
	caller?: Principal;
	index: bigint;
	amount: bigint;
}
export type ResultCall =
	| {
			__kind__: 'Ok';
			Ok: {
				return: Uint8Array;
			};
	  }
	| {
			__kind__: 'Err';
			Err: string;
	  };
export type TxReceiptLegacy =
	| {
			__kind__: 'Ok';
			Ok: bigint;
	  }
	| {
			__kind__: 'Err';
			Err: Variant_InsufficientAllowance_InsufficientBalance;
	  };
export enum BurnError {
	InsufficientBalance = 'InsufficientBalance',
	InvalidTokenContract = 'InvalidTokenContract',
	NotSufficientLiquidity = 'NotSufficientLiquidity'
}
export enum MintError {
	NotSufficientLiquidity = 'NotSufficientLiquidity'
}
export enum Operation {
	transferFrom = 'transferFrom',
	burn = 'burn',
	mint = 'mint',
	approve = 'approve',
	canisterCalled = 'canisterCalled',
	transfer = 'transfer',
	canisterCreated = 'canisterCreated'
}
export enum TransactionStatus {
	FAILED = 'FAILED',
	SUCCEEDED = 'SUCCEEDED'
}
export enum TxError {
	NotifyDfxFailed = 'NotifyDfxFailed',
	InsufficientAllowance = 'InsufficientAllowance',
	UnexpectedCyclesResponse = 'UnexpectedCyclesResponse',
	InsufficientBalance = 'InsufficientBalance',
	InsufficientXTCFee = 'InsufficientXTCFee',
	ErrorOperationStyle = 'ErrorOperationStyle',
	Unauthorized = 'Unauthorized',
	LedgerTrap = 'LedgerTrap',
	ErrorTo = 'ErrorTo',
	Other = 'Other',
	FetchRateFailed = 'FetchRateFailed',
	BlockUsed = 'BlockUsed',
	AmountTooSmall = 'AmountTooSmall'
}
export enum Variant_InsufficientAllowance_InsufficientBalance {
	InsufficientAllowance = 'InsufficientAllowance',
	InsufficientBalance = 'InsufficientBalance'
}
export interface xtc_ledgerInterface {
	/**
	 * BEGIN ERC-20 //////////
	 */
	allowance(arg0: Principal, arg1: Principal): Promise<bigint>;
	approve(arg0: Principal, arg1: bigint): Promise<TxReceipt>;
	balance(arg0: Principal | null): Promise<bigint>;
	balanceOf(arg0: Principal): Promise<bigint>;
	burn(arg0: { canister_id: Principal; amount: bigint }): Promise<BurnResult>;
	decimals(): Promise<number>;
	events(arg0: { offset?: bigint; limit: number }): Promise<EventsConnection>;
	getBlockUsed(): Promise<BigUint64Array>;
	getMetadata(): Promise<Metadata>;
	getTransaction(arg0: bigint): Promise<TxRecord>;
	getTransactions(arg0: bigint, arg1: bigint): Promise<Array<TxRecord>>;
	get_map_block_used(arg0: bigint): Promise<bigint | null>;
	/**
	 * History
	 */
	get_transaction(id: TransactionId): Promise<Event | null>;
	/**
	 * Management
	 */
	halt(): Promise<void>;
	historySize(): Promise<bigint>;
	isBlockUsed(arg0: bigint): Promise<boolean>;
	logo(): Promise<string>;
	mint(arg0: Principal, arg1: bigint): Promise<MintResult>;
	mint_by_icp(arg0: Uint8Array | null, arg1: bigint): Promise<TxReceipt>;
	mint_by_icp_recover(arg0: Uint8Array | null, arg1: bigint, arg2: Principal): Promise<TxReceipt>;
	name(): Promise<string>;
	nameErc20(): Promise<string>;
	/**
	 * Usage statistics
	 */
	stats(): Promise<Stats>;
	symbol_(): Promise<string>;
	totalSupply(): Promise<bigint>;
	transfer(arg0: Principal, arg1: bigint): Promise<TxReceipt>;
	transferErc20(arg0: Principal, arg1: bigint): Promise<TxReceiptLegacy>;
	transferFrom(arg0: Principal, arg1: Principal, arg2: bigint): Promise<TxReceipt>;
	wallet_balance(): Promise<{
		amount: bigint;
	}>;
	/**
	 * Call Forwarding
	 */
	wallet_call(arg0: {
		args: Uint8Array;
		cycles: bigint;
		method_name: string;
		canister: Principal;
	}): Promise<ResultCall>;
	/**
	 * Managing canister
	 */
	wallet_create_canister(arg0: { controller?: Principal; cycles: bigint }): Promise<CreateResult>;
	wallet_create_wallet(arg0: { controller?: Principal; cycles: bigint }): Promise<CreateResult>;
	wallet_send(arg0: { canister: Principal; amount: bigint }): Promise<ResultSend>;
}
export class Xtc_ledger implements xtc_ledgerInterface {
	constructor(private actor: ActorSubclass<_SERVICE>) {}
	async allowance(arg0: Principal, arg1: Principal): Promise<bigint> {
		const result = await this.actor.allowance(arg0, arg1);
		return result;
	}
	async approve(arg0: Principal, arg1: bigint): Promise<TxReceipt> {
		const result = await this.actor.approve(arg0, arg1);
		return from_candid_TxReceipt_n1(result);
	}
	async balance(arg0: Principal | null): Promise<bigint> {
		const result = await this.actor.balance(to_candid_opt_n5(arg0));
		return result;
	}
	async balanceOf(arg0: Principal): Promise<bigint> {
		const result = await this.actor.balanceOf(arg0);
		return result;
	}
	async burn(arg0: { canister_id: Principal; amount: bigint }): Promise<BurnResult> {
		const result = await this.actor.burn(arg0);
		return from_candid_BurnResult_n6(result);
	}
	async decimals(): Promise<number> {
		const result = await this.actor.decimals();
		return result;
	}
	async events(arg0: { offset?: bigint; limit: number }): Promise<EventsConnection> {
		const result = await this.actor.events(to_candid_record_n10(arg0));
		return from_candid_EventsConnection_n11(result);
	}
	async getBlockUsed(): Promise<BigUint64Array> {
		const result = await this.actor.getBlockUsed();
		return result;
	}
	async getMetadata(): Promise<Metadata> {
		const result = await this.actor.getMetadata();
		return result;
	}
	async getTransaction(arg0: bigint): Promise<TxRecord> {
		const result = await this.actor.getTransaction(arg0);
		return from_candid_TxRecord_n21(result);
	}
	async getTransactions(arg0: bigint, arg1: bigint): Promise<Array<TxRecord>> {
		const result = await this.actor.getTransactions(arg0, arg1);
		return from_candid_vec_n25(result);
	}
	async get_map_block_used(arg0: bigint): Promise<bigint | null> {
		const result = await this.actor.get_map_block_used(arg0);
		return from_candid_opt_n26(result);
	}
	async get_transaction(arg0: TransactionId): Promise<Event | null> {
		const result = await this.actor.get_transaction(arg0);
		return from_candid_opt_n27(result);
	}
	async halt(): Promise<void> {
		const result = await this.actor.halt();
		return result;
	}
	async historySize(): Promise<bigint> {
		const result = await this.actor.historySize();
		return result;
	}
	async isBlockUsed(arg0: bigint): Promise<boolean> {
		const result = await this.actor.isBlockUsed(arg0);
		return result;
	}
	async logo(): Promise<string> {
		const result = await this.actor.logo();
		return result;
	}
	async mint(arg0: Principal, arg1: bigint): Promise<MintResult> {
		const result = await this.actor.mint(arg0, arg1);
		return from_candid_MintResult_n28(result);
	}
	async mint_by_icp(arg0: Uint8Array | null, arg1: bigint): Promise<TxReceipt> {
		const result = await this.actor.mint_by_icp(to_candid_opt_n32(arg0), arg1);
		return from_candid_TxReceipt_n1(result);
	}
	async mint_by_icp_recover(
		arg0: Uint8Array | null,
		arg1: bigint,
		arg2: Principal
	): Promise<TxReceipt> {
		const result = await this.actor.mint_by_icp_recover(to_candid_opt_n32(arg0), arg1, arg2);
		return from_candid_TxReceipt_n1(result);
	}
	async name(): Promise<string> {
		const result = await this.actor.name();
		return result;
	}
	async nameErc20(): Promise<string> {
		const result = await this.actor.nameErc20();
		return result;
	}
	async stats(): Promise<Stats> {
		const result = await this.actor.stats();
		return result;
	}
	async symbol_(): Promise<string> {
		const result = await this.actor.symbol();
		return result;
	}
	async totalSupply(): Promise<bigint> {
		const result = await this.actor.totalSupply();
		return result;
	}
	async transfer(arg0: Principal, arg1: bigint): Promise<TxReceipt> {
		const result = await this.actor.transfer(arg0, arg1);
		return from_candid_TxReceipt_n1(result);
	}
	async transferErc20(arg0: Principal, arg1: bigint): Promise<TxReceiptLegacy> {
		const result = await this.actor.transferErc20(arg0, arg1);
		return from_candid_TxReceiptLegacy_n33(result);
	}
	async transferFrom(arg0: Principal, arg1: Principal, arg2: bigint): Promise<TxReceipt> {
		const result = await this.actor.transferFrom(arg0, arg1, arg2);
		return from_candid_TxReceipt_n1(result);
	}
	async wallet_balance(): Promise<{
		amount: bigint;
	}> {
		const result = await this.actor.wallet_balance();
		return result;
	}
	async wallet_call(arg0: {
		args: Uint8Array;
		cycles: bigint;
		method_name: string;
		canister: Principal;
	}): Promise<ResultCall> {
		const result = await this.actor.wallet_call(arg0);
		return from_candid_ResultCall_n36(result);
	}
	async wallet_create_canister(arg0: {
		controller?: Principal;
		cycles: bigint;
	}): Promise<CreateResult> {
		const result = await this.actor.wallet_create_canister(to_candid_record_n38(arg0));
		return from_candid_CreateResult_n39(result);
	}
	async wallet_create_wallet(arg0: {
		controller?: Principal;
		cycles: bigint;
	}): Promise<CreateResult> {
		const result = await this.actor.wallet_create_wallet(to_candid_record_n38(arg0));
		return from_candid_CreateResult_n39(result);
	}
	async wallet_send(arg0: { canister: Principal; amount: bigint }): Promise<ResultSend> {
		const result = await this.actor.wallet_send(arg0);
		return from_candid_ResultSend_n41(result);
	}
}
function from_candid_BurnError_n8(value: _BurnError): BurnError {
	return from_candid_variant_n9(value);
}
function from_candid_BurnResult_n6(value: _BurnResult): BurnResult {
	return from_candid_variant_n7(value);
}
function from_candid_CreateResult_n39(value: _CreateResult): CreateResult {
	return from_candid_variant_n40(value);
}
function from_candid_EventDetail_n18(value: _EventDetail): EventDetail {
	return from_candid_variant_n19(value);
}
function from_candid_Event_n14(value: _Event): Event {
	return from_candid_record_n15(value);
}
function from_candid_EventsConnection_n11(value: _EventsConnection): EventsConnection {
	return from_candid_record_n12(value);
}
function from_candid_MintError_n30(value: _MintError): MintError {
	return from_candid_variant_n31(value);
}
function from_candid_MintResult_n28(value: _MintResult): MintResult {
	return from_candid_variant_n29(value);
}
function from_candid_Operation_n23(value: _Operation): Operation {
	return from_candid_variant_n24(value);
}
function from_candid_ResultCall_n36(value: _ResultCall): ResultCall {
	return from_candid_variant_n37(value);
}
function from_candid_ResultSend_n41(value: _ResultSend): ResultSend {
	return from_candid_variant_n42(value);
}
function from_candid_TransactionStatus_n16(value: _TransactionStatus): TransactionStatus {
	return from_candid_variant_n17(value);
}
function from_candid_TxError_n3(value: _TxError): TxError {
	return from_candid_variant_n4(value);
}
function from_candid_TxReceiptLegacy_n33(value: _TxReceiptLegacy): TxReceiptLegacy {
	return from_candid_variant_n34(value);
}
function from_candid_TxReceipt_n1(value: _TxReceipt): TxReceipt {
	return from_candid_variant_n2(value);
}
function from_candid_TxRecord_n21(value: _TxRecord): TxRecord {
	return from_candid_record_n22(value);
}
function from_candid_opt_n20(value: [] | [Principal]): Principal | null {
	return value.length === 0 ? null : value[0];
}
function from_candid_opt_n26(value: [] | [bigint]): bigint | null {
	return value.length === 0 ? null : value[0];
}
function from_candid_opt_n27(value: [] | [_Event]): Event | null {
	return value.length === 0 ? null : from_candid_Event_n14(value[0]);
}
function from_candid_record_n12(value: {
	data: Array<_Event>;
	next_offset: _TransactionId;
	next_canister_id: [] | [Principal];
}): {
	data: Array<Event>;
	next_offset: TransactionId;
	next_canister_id?: Principal;
} {
	return {
		data: from_candid_vec_n13(value.data),
		next_offset: value.next_offset,
		next_canister_id: record_opt_to_undefined(from_candid_opt_n20(value.next_canister_id))
	};
}
function from_candid_record_n15(value: {
	fee: bigint;
	status: _TransactionStatus;
	kind: _EventDetail;
	cycles: bigint;
	timestamp: bigint;
}): {
	fee: bigint;
	status: TransactionStatus;
	kind: EventDetail;
	cycles: bigint;
	timestamp: bigint;
} {
	return {
		fee: value.fee,
		status: from_candid_TransactionStatus_n16(value.status),
		kind: from_candid_EventDetail_n18(value.kind),
		cycles: value.cycles,
		timestamp: value.timestamp
	};
}
function from_candid_record_n22(value: {
	op: _Operation;
	to: Principal;
	fee: bigint;
	status: _TransactionStatus;
	from: Principal;
	timestamp: _Time;
	caller: [] | [Principal];
	index: bigint;
	amount: bigint;
}): {
	op: Operation;
	to: Principal;
	fee: bigint;
	status: TransactionStatus;
	from: Principal;
	timestamp: Time;
	caller?: Principal;
	index: bigint;
	amount: bigint;
} {
	return {
		op: from_candid_Operation_n23(value.op),
		to: value.to,
		fee: value.fee,
		status: from_candid_TransactionStatus_n16(value.status),
		from: value.from,
		timestamp: value.timestamp,
		caller: record_opt_to_undefined(from_candid_opt_n20(value.caller)),
		index: value.index,
		amount: value.amount
	};
}
function from_candid_variant_n17(
	value:
		| {
				FAILED: null;
		  }
		| {
				SUCCEEDED: null;
		  }
): TransactionStatus {
	return 'FAILED' in value
		? TransactionStatus.FAILED
		: 'SUCCEEDED' in value
			? TransactionStatus.SUCCEEDED
			: value;
}
function from_candid_variant_n19(
	value:
		| {
				Approve: {
					to: Principal;
					from: Principal;
				};
		  }
		| {
				Burn: {
					to: Principal;
					from: Principal;
				};
		  }
		| {
				Mint: {
					to: Principal;
				};
		  }
		| {
				CanisterCreated: {
					from: Principal;
					canister: Principal;
				};
		  }
		| {
				CanisterCalled: {
					from: Principal;
					method_name: string;
					canister: Principal;
				};
		  }
		| {
				Transfer: {
					to: Principal;
					from: Principal;
				};
		  }
		| {
				TransferFrom: {
					to: Principal;
					from: Principal;
					caller: Principal;
				};
		  }
):
	| {
			__kind__: 'Approve';
			Approve: {
				to: Principal;
				from: Principal;
			};
	  }
	| {
			__kind__: 'Burn';
			Burn: {
				to: Principal;
				from: Principal;
			};
	  }
	| {
			__kind__: 'Mint';
			Mint: {
				to: Principal;
			};
	  }
	| {
			__kind__: 'CanisterCreated';
			CanisterCreated: {
				from: Principal;
				canister: Principal;
			};
	  }
	| {
			__kind__: 'CanisterCalled';
			CanisterCalled: {
				from: Principal;
				method_name: string;
				canister: Principal;
			};
	  }
	| {
			__kind__: 'Transfer';
			Transfer: {
				to: Principal;
				from: Principal;
			};
	  }
	| {
			__kind__: 'TransferFrom';
			TransferFrom: {
				to: Principal;
				from: Principal;
				caller: Principal;
			};
	  } {
	return 'Approve' in value
		? {
				__kind__: 'Approve',
				Approve: value.Approve
			}
		: 'Burn' in value
			? {
					__kind__: 'Burn',
					Burn: value.Burn
				}
			: 'Mint' in value
				? {
						__kind__: 'Mint',
						Mint: value.Mint
					}
				: 'CanisterCreated' in value
					? {
							__kind__: 'CanisterCreated',
							CanisterCreated: value.CanisterCreated
						}
					: 'CanisterCalled' in value
						? {
								__kind__: 'CanisterCalled',
								CanisterCalled: value.CanisterCalled
							}
						: 'Transfer' in value
							? {
									__kind__: 'Transfer',
									Transfer: value.Transfer
								}
							: 'TransferFrom' in value
								? {
										__kind__: 'TransferFrom',
										TransferFrom: value.TransferFrom
									}
								: value;
}
function from_candid_variant_n2(
	value:
		| {
				Ok: bigint;
		  }
		| {
				Err: _TxError;
		  }
):
	| {
			__kind__: 'Ok';
			Ok: bigint;
	  }
	| {
			__kind__: 'Err';
			Err: TxError;
	  } {
	return 'Ok' in value
		? {
				__kind__: 'Ok',
				Ok: value.Ok
			}
		: 'Err' in value
			? {
					__kind__: 'Err',
					Err: from_candid_TxError_n3(value.Err)
				}
			: value;
}
function from_candid_variant_n24(
	value:
		| {
				transferFrom: null;
		  }
		| {
				burn: null;
		  }
		| {
				mint: null;
		  }
		| {
				approve: null;
		  }
		| {
				canisterCalled: null;
		  }
		| {
				transfer: null;
		  }
		| {
				canisterCreated: null;
		  }
): Operation {
	return 'transferFrom' in value
		? Operation.transferFrom
		: 'burn' in value
			? Operation.burn
			: 'mint' in value
				? Operation.mint
				: 'approve' in value
					? Operation.approve
					: 'canisterCalled' in value
						? Operation.canisterCalled
						: 'transfer' in value
							? Operation.transfer
							: 'canisterCreated' in value
								? Operation.canisterCreated
								: value;
}
function from_candid_variant_n29(
	value:
		| {
				Ok: _TransactionId;
		  }
		| {
				Err: _MintError;
		  }
):
	| {
			__kind__: 'Ok';
			Ok: TransactionId;
	  }
	| {
			__kind__: 'Err';
			Err: MintError;
	  } {
	return 'Ok' in value
		? {
				__kind__: 'Ok',
				Ok: value.Ok
			}
		: 'Err' in value
			? {
					__kind__: 'Err',
					Err: from_candid_MintError_n30(value.Err)
				}
			: value;
}
function from_candid_variant_n31(value: { NotSufficientLiquidity: null }): MintError {
	return 'NotSufficientLiquidity' in value ? MintError.NotSufficientLiquidity : value;
}
function from_candid_variant_n34(
	value:
		| {
				Ok: bigint;
		  }
		| {
				Err:
					| {
							InsufficientAllowance: null;
					  }
					| {
							InsufficientBalance: null;
					  };
		  }
):
	| {
			__kind__: 'Ok';
			Ok: bigint;
	  }
	| {
			__kind__: 'Err';
			Err: Variant_InsufficientAllowance_InsufficientBalance;
	  } {
	return 'Ok' in value
		? {
				__kind__: 'Ok',
				Ok: value.Ok
			}
		: 'Err' in value
			? {
					__kind__: 'Err',
					Err: from_candid_variant_n35(value.Err)
				}
			: value;
}
function from_candid_variant_n35(
	value:
		| {
				InsufficientAllowance: null;
		  }
		| {
				InsufficientBalance: null;
		  }
): Variant_InsufficientAllowance_InsufficientBalance {
	return 'InsufficientAllowance' in value
		? Variant_InsufficientAllowance_InsufficientBalance.InsufficientAllowance
		: 'InsufficientBalance' in value
			? Variant_InsufficientAllowance_InsufficientBalance.InsufficientBalance
			: value;
}
function from_candid_variant_n37(
	value:
		| {
				Ok: {
					return: Uint8Array;
				};
		  }
		| {
				Err: string;
		  }
):
	| {
			__kind__: 'Ok';
			Ok: {
				return: Uint8Array;
			};
	  }
	| {
			__kind__: 'Err';
			Err: string;
	  } {
	return 'Ok' in value
		? {
				__kind__: 'Ok',
				Ok: value.Ok
			}
		: 'Err' in value
			? {
					__kind__: 'Err',
					Err: value.Err
				}
			: value;
}
function from_candid_variant_n4(
	value:
		| {
				NotifyDfxFailed: null;
		  }
		| {
				InsufficientAllowance: null;
		  }
		| {
				UnexpectedCyclesResponse: null;
		  }
		| {
				InsufficientBalance: null;
		  }
		| {
				InsufficientXTCFee: null;
		  }
		| {
				ErrorOperationStyle: null;
		  }
		| {
				Unauthorized: null;
		  }
		| {
				LedgerTrap: null;
		  }
		| {
				ErrorTo: null;
		  }
		| {
				Other: null;
		  }
		| {
				FetchRateFailed: null;
		  }
		| {
				BlockUsed: null;
		  }
		| {
				AmountTooSmall: null;
		  }
): TxError {
	return 'NotifyDfxFailed' in value
		? TxError.NotifyDfxFailed
		: 'InsufficientAllowance' in value
			? TxError.InsufficientAllowance
			: 'UnexpectedCyclesResponse' in value
				? TxError.UnexpectedCyclesResponse
				: 'InsufficientBalance' in value
					? TxError.InsufficientBalance
					: 'InsufficientXTCFee' in value
						? TxError.InsufficientXTCFee
						: 'ErrorOperationStyle' in value
							? TxError.ErrorOperationStyle
							: 'Unauthorized' in value
								? TxError.Unauthorized
								: 'LedgerTrap' in value
									? TxError.LedgerTrap
									: 'ErrorTo' in value
										? TxError.ErrorTo
										: 'Other' in value
											? TxError.Other
											: 'FetchRateFailed' in value
												? TxError.FetchRateFailed
												: 'BlockUsed' in value
													? TxError.BlockUsed
													: 'AmountTooSmall' in value
														? TxError.AmountTooSmall
														: value;
}
function from_candid_variant_n40(
	value:
		| {
				Ok: {
					canister_id: Principal;
				};
		  }
		| {
				Err: string;
		  }
):
	| {
			__kind__: 'Ok';
			Ok: {
				canister_id: Principal;
			};
	  }
	| {
			__kind__: 'Err';
			Err: string;
	  } {
	return 'Ok' in value
		? {
				__kind__: 'Ok',
				Ok: value.Ok
			}
		: 'Err' in value
			? {
					__kind__: 'Err',
					Err: value.Err
				}
			: value;
}
function from_candid_variant_n42(
	value:
		| {
				Ok: null;
		  }
		| {
				Err: string;
		  }
):
	| {
			__kind__: 'Ok';
			Ok: null;
	  }
	| {
			__kind__: 'Err';
			Err: string;
	  } {
	return 'Ok' in value
		? {
				__kind__: 'Ok',
				Ok: value.Ok
			}
		: 'Err' in value
			? {
					__kind__: 'Err',
					Err: value.Err
				}
			: value;
}
function from_candid_variant_n7(
	value:
		| {
				Ok: _TransactionId;
		  }
		| {
				Err: _BurnError;
		  }
):
	| {
			__kind__: 'Ok';
			Ok: TransactionId;
	  }
	| {
			__kind__: 'Err';
			Err: BurnError;
	  } {
	return 'Ok' in value
		? {
				__kind__: 'Ok',
				Ok: value.Ok
			}
		: 'Err' in value
			? {
					__kind__: 'Err',
					Err: from_candid_BurnError_n8(value.Err)
				}
			: value;
}
function from_candid_variant_n9(
	value:
		| {
				InsufficientBalance: null;
		  }
		| {
				InvalidTokenContract: null;
		  }
		| {
				NotSufficientLiquidity: null;
		  }
): BurnError {
	return 'InsufficientBalance' in value
		? BurnError.InsufficientBalance
		: 'InvalidTokenContract' in value
			? BurnError.InvalidTokenContract
			: 'NotSufficientLiquidity' in value
				? BurnError.NotSufficientLiquidity
				: value;
}
function from_candid_vec_n13(value: Array<_Event>): Array<Event> {
	return value.map((x) => from_candid_Event_n14(x));
}
function from_candid_vec_n25(value: Array<_TxRecord>): Array<TxRecord> {
	return value.map((x) => from_candid_TxRecord_n21(x));
}
function to_candid_opt_n32(value: Uint8Array | null): [] | [Uint8Array] {
	return value === null ? candid_none() : candid_some(value);
}
function to_candid_opt_n5(value: Principal | null): [] | [Principal] {
	return value === null ? candid_none() : candid_some(value);
}
function to_candid_record_n10(value: { offset?: bigint; limit: number }): {
	offset: [] | [bigint];
	limit: number;
} {
	return {
		offset: value.offset ? candid_some(value.offset) : candid_none(),
		limit: value.limit
	};
}
function to_candid_record_n38(value: { controller?: Principal; cycles: bigint }): {
	controller: [] | [Principal];
	cycles: bigint;
} {
	return {
		controller: value.controller ? candid_some(value.controller) : candid_none(),
		cycles: value.cycles
	};
}
export interface CreateActorOptions {
	agent?: Agent;
	agentOptions?: HttpAgentOptions;
	actorOptions?: ActorConfig;
}
export function createActor(canisterId: string, options: CreateActorOptions = {}): Xtc_ledger {
	const agent =
		options.agent ||
		HttpAgent.createSync({
			...options.agentOptions
		});
	if (options.agent && options.agentOptions) {
		console.warn(
			'Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent.'
		);
	}
	const actor = Actor.createActor<_SERVICE>(idlFactory, {
		agent,
		canisterId: canisterId,
		...options.actorOptions
	});
	return new Xtc_ledger(actor);
}
