/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @icp-sdk/bindgen@0.1.2.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import type { ActorMethod } from '@icp-sdk/core/agent';
import type { IDL } from '@icp-sdk/core/candid';

export type AddLiquiditAmountsResult = { Ok: AddLiquidityAmountsReply } | { Err: string };
export interface AddLiquidityAmountsReply {
	add_lp_token_amount: bigint;
	amount_0: bigint;
	amount_1: bigint;
	address_0: string;
	address_1: string;
	symbol_0: string;
	symbol_1: string;
	chain_0: string;
	chain_1: string;
	symbol: string;
	fee_0: bigint;
	fee_1: bigint;
}
export interface AddLiquidityArgs {
	token_0: string;
	token_1: string;
	amount_0: bigint;
	amount_1: bigint;
	tx_id_0: [] | [TxId];
	tx_id_1: [] | [TxId];
}
export type AddLiquidityAsyncResult = { Ok: bigint } | { Err: string };
export interface AddLiquidityReply {
	ts: bigint;
	request_id: bigint;
	status: string;
	tx_id: bigint;
	add_lp_token_amount: bigint;
	transfer_ids: Array<TransferIdReply>;
	amount_0: bigint;
	amount_1: bigint;
	claim_ids: BigUint64Array;
	address_0: string;
	address_1: string;
	symbol_0: string;
	symbol_1: string;
	chain_0: string;
	chain_1: string;
	symbol: string;
}
export type AddLiquidityResult = { Ok: AddLiquidityReply } | { Err: string };
export interface AddPoolArgs {
	token_0: string;
	token_1: string;
	amount_0: bigint;
	amount_1: bigint;
	tx_id_0: [] | [TxId];
	tx_id_1: [] | [TxId];
	lp_fee_bps: [] | [number];
}
export interface AddPoolReply {
	ts: bigint;
	request_id: bigint;
	status: string;
	tx_id: bigint;
	lp_token_symbol: string;
	add_lp_token_amount: bigint;
	transfer_ids: Array<TransferIdReply>;
	name: string;
	amount_0: bigint;
	amount_1: bigint;
	claim_ids: BigUint64Array;
	address_0: string;
	address_1: string;
	symbol_0: string;
	symbol_1: string;
	pool_id: number;
	chain_0: string;
	chain_1: string;
	is_removed: boolean;
	symbol: string;
	lp_fee_bps: number;
}
export type AddPoolResult = { Ok: AddPoolReply } | { Err: string };
export interface AddTokenArgs {
	token: string;
}
export type AddTokenReply = { IC: ICTokenReply };
export type AddTokenResult = { Ok: AddTokenReply } | { Err: string };
export interface CheckPoolsReply {
	expected_balance: ExpectedBalance;
	diff_balance: bigint;
	actual_balance: bigint;
	symbol: string;
}
export type CheckPoolsResult = { Ok: Array<CheckPoolsReply> } | { Err: string };
export interface ClaimReply {
	ts: bigint;
	fee: bigint;
	status: string;
	claim_id: bigint;
	transfer_ids: Array<TransferIdReply>;
	desc: string;
	chain: string;
	canister_id: [] | [string];
	to_address: string;
	amount: bigint;
	symbol: string;
}
export type ClaimResult = { Ok: ClaimReply } | { Err: string };
export interface ClaimsReply {
	ts: bigint;
	fee: bigint;
	status: string;
	claim_id: bigint;
	desc: string;
	chain: string;
	canister_id: [] | [string];
	to_address: string;
	amount: bigint;
	symbol: string;
}
export type ClaimsResult = { Ok: Array<ClaimsReply> } | { Err: string };
export interface ExpectedBalance {
	balance: bigint;
	pool_balances: Array<PoolExpectedBalance>;
	unclaimed_claims: bigint;
}
export interface ICTokenReply {
	fee: bigint;
	decimals: number;
	token_id: number;
	chain: string;
	name: string;
	canister_id: string;
	icrc1: boolean;
	icrc2: boolean;
	icrc3: boolean;
	is_removed: boolean;
	symbol: string;
}
export interface ICTransferReply {
	is_send: boolean;
	block_index: bigint;
	chain: string;
	canister_id: string;
	amount: bigint;
	symbol: string;
}
export interface Icrc10SupportedStandards {
	url: string;
	name: string;
}
export interface Icrc28TrustedOriginsResponse {
	trusted_origins: Array<string>;
}
export interface LPBalancesReply {
	ts: bigint;
	usd_balance: number;
	balance: number;
	name: string;
	amount_0: number;
	amount_1: number;
	address_0: string;
	address_1: string;
	symbol_0: string;
	symbol_1: string;
	usd_amount_0: number;
	usd_amount_1: number;
	chain_0: string;
	chain_1: string;
	symbol: string;
	lp_token_id: bigint;
}
export interface LPTokenReply {
	fee: bigint;
	decimals: number;
	token_id: number;
	chain: string;
	name: string;
	address: string;
	pool_id_of: number;
	is_removed: boolean;
	total_supply: bigint;
	symbol: string;
}
export interface MessagesReply {
	ts: bigint;
	title: string;
	message: string;
	message_id: bigint;
}
export type MessagesResult = { Ok: Array<MessagesReply> } | { Err: string };
export interface PoolExpectedBalance {
	balance: bigint;
	kong_fee: bigint;
	pool_symbol: string;
	lp_fee: bigint;
}
export interface PoolReply {
	lp_token_symbol: string;
	name: string;
	lp_fee_0: bigint;
	lp_fee_1: bigint;
	balance_0: bigint;
	balance_1: bigint;
	address_0: string;
	address_1: string;
	symbol_0: string;
	symbol_1: string;
	pool_id: number;
	price: number;
	chain_0: string;
	chain_1: string;
	is_removed: boolean;
	symbol: string;
	lp_fee_bps: number;
}
export type PoolsResult = { Ok: Array<PoolReply> } | { Err: string };
export interface RemoveLiquidityAmountsReply {
	lp_fee_0: bigint;
	lp_fee_1: bigint;
	amount_0: bigint;
	amount_1: bigint;
	address_0: string;
	address_1: string;
	symbol_0: string;
	symbol_1: string;
	chain_0: string;
	chain_1: string;
	remove_lp_token_amount: bigint;
	symbol: string;
}
export type RemoveLiquidityAmountsResult =
	| {
			Ok: RemoveLiquidityAmountsReply;
	  }
	| { Err: string };
export interface RemoveLiquidityArgs {
	token_0: string;
	token_1: string;
	remove_lp_token_amount: bigint;
}
export type RemoveLiquidityAsyncResult = { Ok: bigint } | { Err: string };
export interface RemoveLiquidityReply {
	ts: bigint;
	request_id: bigint;
	status: string;
	tx_id: bigint;
	transfer_ids: Array<TransferIdReply>;
	lp_fee_0: bigint;
	lp_fee_1: bigint;
	amount_0: bigint;
	amount_1: bigint;
	claim_ids: BigUint64Array;
	address_0: string;
	address_1: string;
	symbol_0: string;
	symbol_1: string;
	chain_0: string;
	chain_1: string;
	remove_lp_token_amount: bigint;
	symbol: string;
}
export type RemoveLiquidityResult = { Ok: RemoveLiquidityReply } | { Err: string };
export type RequestReply =
	| { AddLiquidity: AddLiquidityReply }
	| { Swap: SwapReply }
	| { AddPool: AddPoolReply }
	| { RemoveLiquidity: RemoveLiquidityReply }
	| { Pending: null };
export type RequestRequest =
	| { AddLiquidity: AddLiquidityArgs }
	| { Swap: SwapArgs }
	| { AddPool: AddPoolArgs }
	| { RemoveLiquidity: RemoveLiquidityArgs };
export interface RequestsReply {
	ts: bigint;
	request_id: bigint;
	request: RequestRequest;
	statuses: Array<string>;
	reply: RequestReply;
}
export type RequestsResult = { Ok: Array<RequestsReply> } | { Err: string };
export interface SendArgs {
	token: string;
	to_address: string;
	amount: bigint;
}
export interface SendReply {
	ts: bigint;
	request_id: bigint;
	status: string;
	tx_id: bigint;
	chain: string;
	to_address: string;
	amount: bigint;
	symbol: string;
}
export type SendResult = { OK: SendReply } | { Err: string };
export interface SwapAmountsReply {
	txs: Array<SwapAmountsTxReply>;
	receive_chain: string;
	mid_price: number;
	pay_amount: bigint;
	receive_amount: bigint;
	pay_symbol: string;
	receive_symbol: string;
	receive_address: string;
	pay_address: string;
	price: number;
	pay_chain: string;
	slippage: number;
}
export type SwapAmountsResult = { Ok: SwapAmountsReply } | { Err: string };
export interface SwapAmountsTxReply {
	receive_chain: string;
	pay_amount: bigint;
	receive_amount: bigint;
	pay_symbol: string;
	receive_symbol: string;
	receive_address: string;
	pool_symbol: string;
	pay_address: string;
	price: number;
	pay_chain: string;
	lp_fee: bigint;
	gas_fee: bigint;
}
export interface SwapArgs {
	receive_token: string;
	max_slippage: [] | [number];
	pay_amount: bigint;
	referred_by: [] | [string];
	receive_amount: [] | [bigint];
	receive_address: [] | [string];
	pay_token: string;
	pay_tx_id: [] | [TxId];
}
export type SwapAsyncResult = { Ok: bigint } | { Err: string };
export interface SwapReply {
	ts: bigint;
	txs: Array<SwapTxReply>;
	request_id: bigint;
	status: string;
	tx_id: bigint;
	transfer_ids: Array<TransferIdReply>;
	receive_chain: string;
	mid_price: number;
	pay_amount: bigint;
	receive_amount: bigint;
	claim_ids: BigUint64Array;
	pay_symbol: string;
	receive_symbol: string;
	receive_address: string;
	pay_address: string;
	price: number;
	pay_chain: string;
	slippage: number;
}
export type SwapResult = { Ok: SwapReply } | { Err: string };
export interface SwapTxReply {
	ts: bigint;
	receive_chain: string;
	pay_amount: bigint;
	receive_amount: bigint;
	pay_symbol: string;
	receive_symbol: string;
	receive_address: string;
	pool_symbol: string;
	pay_address: string;
	price: number;
	pay_chain: string;
	lp_fee: bigint;
	gas_fee: bigint;
}
export type TokenReply = { IC: ICTokenReply } | { LP: LPTokenReply };
export type TokensResult = { Ok: Array<TokenReply> } | { Err: string };
export interface TransferIdReply {
	transfer_id: bigint;
	transfer: TransferReply;
}
export type TransferReply = { IC: ICTransferReply };
export type TransfersResult = { Ok: Array<TransferIdReply> } | { Err: string };
export type TxId = { TransactionId: string } | { BlockIndex: bigint };
export type TxsReply =
	| { AddLiquidity: AddLiquidityReply }
	| { Swap: SwapReply }
	| { AddPool: AddPoolReply }
	| { RemoveLiquidity: RemoveLiquidityReply };
export type TxsResult = { Ok: Array<TxsReply> } | { Err: string };
export interface UpdateTokenArgs {
	token: string;
}
export type UpdateTokenReply = { IC: ICTokenReply };
export type UpdateTokenResult = { Ok: UpdateTokenReply } | { Err: string };
export type UserBalancesReply = { LP: LPBalancesReply };
export type UserBalancesResult = { Ok: Array<UserBalancesReply> } | { Err: string };
export interface UserReply {
	account_id: string;
	fee_level_expires_at: [] | [bigint];
	referred_by: [] | [string];
	user_id: number;
	fee_level: number;
	principal_id: string;
	referred_by_expires_at: [] | [bigint];
	my_referral_code: string;
}
export type UserResult = { Ok: UserReply } | { Err: string };
export type ValidateAddLiquidityResult = { Ok: string } | { Err: string };
export type ValidateRemoveLiquidityResult = { Ok: string } | { Err: string };
export interface icrc21_consent_info {
	/**
	 * Metadata of the consent_message.
	 */
	metadata: icrc21_consent_message_metadata;
	/**
	 * Consent message describing in a human-readable format what the call will do.
	 *
	 * The message should adhere as close as possible to the user_preferences specified in the consent_message_spec
	 * of the icrc21_consent_message_request.
	 * If the message is not available for the given user_preferences any fallback message should be used. Providing a
	 * message should be preferred over sending an icrc21_error.
	 * The metadata must match the consent_message provided.
	 *
	 * The message should be short and concise.
	 * It should only contain information that is:
	 * * relevant to the user
	 * * relevant given the canister call argument
	 *
	 * The message must fit the following context shown to
	 * the user on the signer UI:
	 * ┌─────────────────────────────────┐
	 * │  Approve the following action?  │
	 * │  ┌───────────────────────────┐  │
	 * │  │    <consent_message>      │  │
	 * │  └───────────────────────────┘  │
	 * │  ┌───────────┐   ┌───────────┐  │
	 * │  │  Reject   │   │  Approve  │  │
	 * │  └───────────┘   └───────────┘  │
	 * └─────────────────────────────────┘
	 */
	consent_message: icrc21_consent_message;
}
export type icrc21_consent_message =
	| {
			/**
			 * Message for a simple display able to handle pages with multiple lines of text with a fixed maximum number of
			 * characters per line.
			 * Multiple pages can be used if the text does no fit on a single page.
			 * Uses plain text, without any embedded formatting elements.
			 */
			LineDisplayMessage: {
				pages: Array<{
					/**
					 * Lines of text to be displayed on a single page.
					 * Must not have more entries (lines) than specified in the icrc21_consent_message_spec.
					 * Lines must not exceed the number of characters per line specified in the icrc21_consent_message_spec.
					 */
					lines: Array<string>;
				}>;
			};
	  }
	| {
			/**
			 * Message for a generic display able to handle large documents and do proper line wrapping and pagination / scrolling.
			 * Uses Markdown formatting, no external resources (e.g. images) are allowed.
			 */
			GenericDisplayMessage: string;
	  };
export interface icrc21_consent_message_metadata {
	/**
	 * The users local timezone offset in minutes from UTC.
	 * Applicable when converting timestamps to human-readable format.
	 *
	 * If absent in the request, the canister should fallback to the UTC timezone when creating the consent message.
	 * If absent in the response, the canister is indicating that the consent message is not timezone sensitive.
	 */
	utc_offset_minutes: [] | [number];
	/**
	 * BCP-47 language tag. See https://www.rfc-editor.org/rfc/bcp/bcp47.txt
	 */
	language: string;
}
export interface icrc21_consent_message_request {
	/**
	 * Argument of the canister call.
	 */
	arg: Uint8Array;
	/**
	 * Method name of the canister call.
	 */
	method: string;
	/**
	 * User preferences with regards to the consent message presented to the end-user.
	 */
	user_preferences: icrc21_consent_message_spec;
}
export type icrc21_consent_message_response =
	| {
			/**
			 * The call is ok, consent message is provided.
			 */
			Ok: icrc21_consent_info;
	  }
	| {
			/**
			 * The call is not ok, error is provided.
			 */
			Err: icrc21_error;
	  };
export interface icrc21_consent_message_spec {
	/**
	 * Metadata of the consent message.
	 */
	metadata: icrc21_consent_message_metadata;
	/**
	 * Information about the device responsible for presenting the consent message to the user.
	 * If absent in the request, the canister should fallback to one of the values defined in this spec (ICRC-21).
	 */
	device_spec:
		| []
		| [
				| {
						/**
						 * A generic display able to handle large documents and do line wrapping and pagination / scrolling.
						 * Text must be Markdown formatted, no external resources (e.g. images) are allowed.
						 */
						GenericDisplay: null;
				  }
				| {
						/**
						 * Simple display able to handle lines of text with a maximum number of characters per line.
						 * Multiple pages can be used if the text does no fit on a single page.
						 * Text must be plain text without any embedded formatting elements.
						 */
						LineDisplay: {
							/**
							 * Maximum number of characters that can be displayed per line.
							 */
							characters_per_line: number;
							/**
							 * Maximum number of lines that can be displayed at once on a single page.
							 */
							lines_per_page: number;
						};
				  }
		  ];
}
export type icrc21_error =
	| {
			/**
			 * Any error not covered by the above variants.
			 */
			GenericError: {
				/**
				 * Human readable technical description of the error intended for developers, not the end-user.
				 */
				description: string;
				/**
				 * Machine parsable error. Can be chosen by the target canister but should indicate the error category.
				 */
				error_code: bigint;
			};
	  }
	| {
			/**
			 * The canister did not provide a consent message for because payment was missing or insufficient.
			 *
			 * This error is used to account for payment extensions to be added in the future:
			 * While small consent messages are easy and cheap to provide, this might not generally be the case for all consent
			 * messages. To avoid future breaking changes, when introducing a payment flow, this error is already introduced
			 * even though there no standardized payment flow yet.
			 */
			InsufficientPayment: icrc21_error_info;
	  }
	| {
			/**
			 * The canister does not support this call (i.e. it will lead to a rejection or error response).
			 * Reasons might be (non-exhaustive list):
			 * * the canister call is malformed (e.g. wrong method name, argument cannot be decoded)
			 * * the arguments exceed certain bounds
			 *
			 * The developer should provide more information about the error using the description in icrc21_error_info.
			 */
			UnsupportedCanisterCall: icrc21_error_info;
	  }
	| {
			/**
			 * The canister cannot produce a consent message for this call.
			 * Reasons might be (non-exhaustive list):
			 * * it is an internal call not intended for end-users
			 * * the canister developer has not yet implemented a consent message for this call
			 *
			 * The developer should provide more information about the error using the description in icrc21_error_info.
			 */
			ConsentMessageUnavailable: icrc21_error_info;
	  };
export interface icrc21_error_info {
	/**
	 * Human readable technical description of the error intended for developers, not the end-user.
	 */
	description: string;
}
export interface _SERVICE {
	/**
	 * adds token_0 and token_1 to the liqudity pool in return for LP tokens
	 * - add_liquidity() has 2 variations:
	 * 1) 2 x icrc2_approve + icrc2_transfer_from - user must icrc2_approve the amount_0+gas of token_0, amount_1+gas of token_1 and then call add_liquidity() where the canister will then icrc2_transfer_from
	 * 2) 2 x icrc1_transfer - user must icrc1_transfer the amount_0 of token_0, amount_1 of token_1 and then call add_liquidity() with the block index (tx_id_0 and tx_id_1)
	 */
	add_liquidity: ActorMethod<[AddLiquidityArgs], AddLiquidityResult>;
	/**
	 * add_liquidity_amounts(token_0, amount_0, token_1)
	 * token_0, token_1 - format Symbol, Chain.Symbol, CanisterId or Chain.CanisterId ie. ckBTC, IC.ckBTC, or IC.ryjl3-tyaaa-aaaaa-aaaba-cai
	 * amount_0, amount_1 - Nat numbers with corresponding decimal precision as defined in ledger canister
	 * - calculates the required amount_1 to add liquidity to pool
	 * - results of add_liquidity_amounts() are then pass to add_liquidity() for execution
	 */
	add_liquidity_amounts: ActorMethod<[string, bigint, string], AddLiquiditAmountsResult>;
	/**
	 * asnychronous version of add_liquidity()
	 * request_id will be returned by add_liquidity_async() and poll requests(request_id) to get updated status
	 */
	add_liquidity_async: ActorMethod<[AddLiquidityArgs], AddLiquidityAsyncResult>;
	/**
	 * add a new liquidity pool and token
	 */
	add_pool: ActorMethod<[AddPoolArgs], AddPoolResult>;
	/**
	 * add a new token
	 */
	add_token: ActorMethod<[AddTokenArgs], AddTokenResult>;
	/**
	 * admin functions
	 */
	check_pools: ActorMethod<[], CheckPoolsResult>;
	/**
	 * claim(claim_id) - claim claim_id
	 */
	claim: ActorMethod<[bigint], ClaimResult>;
	/**
	 * claims(principal_id) - return list of claims for user
	 */
	claims: ActorMethod<[string], ClaimsResult>;
	/**
	 * user() - returns user information
	 */
	get_user: ActorMethod<[], UserResult>;
	icrc10_supported_standards: ActorMethod<[], Array<Icrc10SupportedStandards>>;
	/**
	 * icrc1 standards
	 */
	icrc1_name: ActorMethod<[], string>;
	icrc21_canister_call_consent_message: ActorMethod<
		[icrc21_consent_message_request],
		icrc21_consent_message_response
	>;
	icrc28_trusted_origins: ActorMethod<[], Icrc28TrustedOriginsResponse>;
	/**
	 * pools(opt wildcard) - returns all pools or wildcard search
	 */
	pools: ActorMethod<[[] | [string]], PoolsResult>;
	/**
	 * redeems remove_lp_token_amount of LP tokens to the pool and receives token_0 and token_1 in return
	 */
	remove_liquidity: ActorMethod<[RemoveLiquidityArgs], RemoveLiquidityResult>;
	/**
	 * remove_liquidity_amounts(token_0, token_1, remove_lp_token_amount)
	 * calcalates the expected token_0 and token_1 to be received from redeeming remove_lp_token_amount of LP tokens to the pool
	 */
	remove_liquidity_amounts: ActorMethod<[string, string, bigint], RemoveLiquidityAmountsResult>;
	/**
	 * asnychronous version of remove_liquidity()
	 * request_id will be returned by remove_liquidity_async() and poll requests(request_id) to get updated status
	 */
	remove_liquidity_async: ActorMethod<[RemoveLiquidityArgs], RemoveLiquidityAsyncResult>;
	/**
	 * requests(opt request_id) - return specific request_id
	 */
	requests: ActorMethod<[[] | [bigint]], RequestsResult>;
	/**
	 * send LP tokens to another user
	 */
	send: ActorMethod<[SendArgs], SendResult>;
	/**
	 * swap()
	 * pay_token, receive_token - format Symbol, Chain.Symbol, CanisterId or Chain.CanisterId ie. ckBTC, IC.ckBTC, or IC.ryjl3-tyaaa-aaaaa-aaaba-cai
	 * pay_amount, receive_amount - Nat numbers with corresponding decimal precision as defined in ledger canister
	 * - swaps pay_amount of pay_token into receive_amount of receive_token
	 * - swap() has 2 variations:
	 * 1) icrc2_approve + icrc2_transfer_from - user must icrc2_approve the pay_amount+gas of pay_token and then call swap() where the canister will then icrc2_transfer_from
	 * 2) icrc1_transfer - user must icrc1_transfer the pay_amount of pay_token and then call swap() with the block index
	 */
	swap: ActorMethod<[SwapArgs], SwapResult>;
	/**
	 * swap_amounts(pay_token, pay_amount, receive_token)
	 * pay_token, receive_token - format Symbol, Chain.Symbol, CanisterId or Chain.CanisterId ie. ckBTC, IC.ckBTC, or IC.ryjl3-tyaaa-aaaaa-aaaba-cai
	 * pay_amount, receive_amount - Nat numbers with corresponding decimal precision as defined in ledger canister
	 * - calculates the expected receive_amount and price of the swap
	 * - results of swap_amounts() are then pass to swap() for execution
	 */
	swap_amounts: ActorMethod<[string, bigint, string], SwapAmountsResult>;
	/**
	 * asnychronous version of swap()
	 * request_id will be returned by swap_async() and poll requests(request_id) to get updated status
	 */
	swap_async: ActorMethod<[SwapArgs], SwapAsyncResult>;
	/**
	 * tokens(opt wildcard) - returns all tokens or wildcard search
	 */
	tokens: ActorMethod<[[] | [string]], TokensResult>;
	/**
	 * update token details
	 */
	update_token: ActorMethod<[UpdateTokenArgs], UpdateTokenResult>;
	/**
	 * user_balances(principal_id) - return user's LP balances
	 */
	user_balances: ActorMethod<[string], UserBalancesResult>;
	/**
	 * validate add_liquidity for SNS proposals
	 */
	validate_add_liquidity: ActorMethod<[], ValidateAddLiquidityResult>;
	/**
	 * validate remove_liquidity for SNS proposals
	 */
	validate_remove_liquidity: ActorMethod<[], ValidateRemoveLiquidityResult>;
}
export declare const idlService: IDL.ServiceClass;
export declare const idlInitArgs: IDL.Type[];
export declare const idlFactory: IDL.InterfaceFactory;
export declare const init: (args: { IDL: typeof IDL }) => IDL.Type[];
