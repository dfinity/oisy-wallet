<script lang="ts">
	import IcReceiveCkEthereum from '$icp/components/receive/IcReceiveCkEthereum.svelte';
	import IcReceiveIcp from '$icp/components/receive/IcReceiveICP.svelte';
	import IcReceiveCkBTC from '$icp/components/receive/IcReceiveCkBTC.svelte';
	import IcReceiveIcrc from '$icp/components/receive/IcReceiveIcrc.svelte';
	import type { Token } from '$lib/types/token';
	import {
		isTokenCkBtcLedger,
		isTokenCkErc20Ledger,
		isTokenCkEthLedger
	} from '$icp/utils/ic-send.utils';
	import type { IcToken } from '$icp/types/ic';
	import { setContext } from 'svelte';
	import {
		initReceiveTokenContext,
		RECEIVE_TOKEN_CONTEXT_KEY,
		type ReceiveTokenContext
	} from '$icp/stores/receive-token.store';

	export let token: Token;

	let ckEthereum = false;
	$: ckEthereum = isTokenCkEthLedger(token as IcToken) || isTokenCkErc20Ledger(token as IcToken);

	let ckBTC = false;
	$: ckBTC = isTokenCkBtcLedger(token as IcToken);

	let icrc = false;
	$: icrc = token.standard === 'icrc';

	/**
	 * Context for the IC receive modals: We initialize with a token, ensuring that the information is never undefined.
	 */
	const context = initReceiveTokenContext(token);
	setContext<ReceiveTokenContext>(RECEIVE_TOKEN_CONTEXT_KEY, context);

	// At boot time, if the context is derived globally, the token might be updated a few times. That's why we also update it with an auto-subscriber.
	$: token, (() => context.token.set(token as IcToken))();
</script>

{#if ckEthereum}
	<IcReceiveCkEthereum />
{:else if ckBTC}
	<IcReceiveCkBTC />
{:else if icrc}
	<IcReceiveIcrc />
{:else}
	<IcReceiveIcp />
{/if}
