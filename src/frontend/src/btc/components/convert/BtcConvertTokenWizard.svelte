<script lang="ts">
	import type { WizardStep } from '@dfinity/gix-components';
	import { isNullish, nonNullish } from '@dfinity/utils';
	import { createEventDispatcher, getContext, onMount } from 'svelte';
	import BtcConvertForm from '$btc/components/convert/BtcConvertForm.svelte';
	import BtcConvertProgress from '$btc/components/convert/BtcConvertProgress.svelte';
	import BtcConvertReview from '$btc/components/convert/BtcConvertReview.svelte';
	import UtxosFeeContext from '$btc/components/fee/UtxosFeeContext.svelte';
	import { loadBtcPendingSentTransactions } from '$btc/services/btc-pending-sent-transactions.services';
	import {
		handleBtcValidationError,
		sendBtc,
		validateBtcSend
	} from '$btc/services/btc-send.services';
	import { UTXOS_FEE_CONTEXT_KEY } from '$btc/stores/utxos-fee.store';
	import { BtcValidationError } from '$btc/types/btc-send';
	import { btcAddressStore } from '$icp/stores/btc.store';
	import ButtonBack from '$lib/components/ui/ButtonBack.svelte';
	import ButtonCancel from '$lib/components/ui/ButtonCancel.svelte';
	import {
		TRACK_COUNT_BTC_VALIDATION_ERROR,
		TRACK_COUNT_CONVERT_BTC_TO_CKBTC_ERROR,
		TRACK_COUNT_CONVERT_BTC_TO_CKBTC_SUCCESS
	} from '$lib/constants/analytics.contants';
	import {
		btcAddressMainnet,
		btcAddressRegtest,
		btcAddressTestnet
	} from '$lib/derived/address.derived';
	import { authIdentity } from '$lib/derived/auth.derived';
	import { ProgressStepsConvert } from '$lib/enums/progress-steps';
	import { WizardStepsConvert } from '$lib/enums/wizard-steps';
	import { trackEvent } from '$lib/services/analytics.services';
	import { nullishSignOut } from '$lib/services/auth.services';
	import { CONVERT_CONTEXT_KEY, type ConvertContext } from '$lib/stores/convert.store';
	import { i18n } from '$lib/stores/i18n.store';
	import { toastsError } from '$lib/stores/toasts.store';
	import type { NetworkId } from '$lib/types/network';
	import type { OptionAmount } from '$lib/types/send';
	import { invalidAmount, isNullishOrEmpty } from '$lib/utils/input.utils';
	import {
		isNetworkIdBTCRegtest,
		isNetworkIdBTCTestnet,
		mapNetworkIdToBitcoinNetwork
	} from '$lib/utils/network.utils';

	export let currentStep: WizardStep | undefined;
	export let sendAmount: OptionAmount;
	export let receiveAmount: number | undefined;
	export let convertProgressStep: string;
	export let formCancelAction: 'back' | 'close' = 'close';

	const { store: utxosFeeStore } = getContext<UtxosFeeContext>(UTXOS_FEE_CONTEXT_KEY);

	const { sourceToken, destinationToken } = getContext<ConvertContext>(CONVERT_CONTEXT_KEY);

	const progress = (step: ProgressStepsConvert) => (convertProgressStep = step);

	let amountError: boolean;

	let networkId: NetworkId | undefined = undefined;
	$: networkId = $sourceToken.network.id;

	let sourceAddress: string;
	$: sourceAddress =
		(isNetworkIdBTCTestnet(networkId)
			? $btcAddressTestnet
			: isNetworkIdBTCRegtest(networkId)
				? $btcAddressRegtest
				: $btcAddressMainnet) ?? '';

	let destinationAddress: string | undefined = undefined;
	// BTC address generated by the ckBTC minter which needs to be used for BTC -> ckBTC conversion
	// Docs: https://github.com/dfinity/ic/blob/master/rs/bitcoin/ckbtc/minter/README.adoc#bitcoin-to-ckbtc
	$: destinationAddress = $btcAddressStore?.[$destinationToken.id]?.data;

	onMount(() => {
		loadBtcPendingSentTransactions({
			identity: $authIdentity,
			networkId,
			address: sourceAddress
		});
	});

	const dispatch = createEventDispatcher();

	const convert = async () => {
		const network = nonNullish(networkId) ? mapNetworkIdToBitcoinNetwork(networkId) : undefined;

		if (isNullish($authIdentity)) {
			await nullishSignOut();
			return;
		}

		// The data has been already validated in the previous conversion flow steps.
		if (
			isNullish(network) ||
			isNullishOrEmpty(destinationAddress) ||
			invalidAmount(sendAmount) ||
			isNullish(sendAmount) ||
			isNullish($utxosFeeStore?.utxosFee)
		) {
			toastsError({
				msg: { text: $i18n.convert.error.unexpected_missing_data }
			});
			return;
		}

		dispatch('icNext');

		// Validate UTXOs before proceeding
		const { utxosFee } = $utxosFeeStore;
		progress(ProgressStepsConvert.INITIALIZATION);
		try {
			await validateBtcSend({
				utxosFee,
				source: sourceAddress,
				amount: sendAmount,
				network,
				identity: $authIdentity
			});
		} catch (err: unknown) {
			// Handle BtcValidationError with specific toastsError for each type
			if (err instanceof BtcValidationError) {
				await handleBtcValidationError({ err });
				utxosFee.error = err.type;
			}

			trackEvent({
				name: TRACK_COUNT_BTC_VALIDATION_ERROR,
				metadata: {
					token: utxosFee.symbol,
					network: `${networkId?.description ?? 'unknown'}`
				}
			});

			// go back to the previous step so the user can correct/ try again
			dispatch('icBack');
			return;
		}

		try {
			progress(ProgressStepsConvert.CONVERT);
			await sendBtc({
				destination: destinationAddress,
				amount: sendAmount,
				utxosFee: $utxosFeeStore.utxosFee,
				network,
				source: sourceAddress,
				identity: $authIdentity,
				onProgress: () => {
					progress(ProgressStepsConvert.UPDATE_UI);
				}
			});

			progress(ProgressStepsConvert.DONE);

			trackEvent({
				name: TRACK_COUNT_CONVERT_BTC_TO_CKBTC_SUCCESS
			});

			setTimeout(() => close(), 750);
		} catch (err: unknown) {
			toastsError({
				msg: { text: $i18n.convert.error.unexpected },
				err
			});

			trackEvent({
				name: TRACK_COUNT_CONVERT_BTC_TO_CKBTC_ERROR
			});

			back();
		}
	};

	const close = () => dispatch('icClose');
	const back = () => dispatch('icBack');
</script>

<UtxosFeeContext amount={sendAmount} {amountError} {networkId} source={sourceAddress}>
	{#if currentStep?.name === WizardStepsConvert.CONVERT}
		<BtcConvertForm
			source={sourceAddress}
			on:icNext
			on:icClose
			bind:sendAmount
			bind:receiveAmount
			bind:amountError
		>
			<svelte:fragment slot="cancel">
				{#if formCancelAction === 'back'}
					<ButtonBack onclick={back} />
				{:else}
					<ButtonCancel onclick={close} />
				{/if}
			</svelte:fragment>
		</BtcConvertForm>
	{:else if currentStep?.name === WizardStepsConvert.REVIEW}
		<BtcConvertReview {receiveAmount} {sendAmount} on:icConvert={convert} on:icBack>
			<ButtonBack slot="cancel" onclick={back} />
		</BtcConvertReview>
	{:else if currentStep?.name === WizardStepsConvert.CONVERTING}
		<BtcConvertProgress bind:convertProgressStep />
	{:else}
		<slot />
	{/if}
</UtxosFeeContext>
