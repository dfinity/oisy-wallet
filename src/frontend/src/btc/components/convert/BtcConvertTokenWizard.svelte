<script lang="ts">
	import type { WizardStep } from '@dfinity/gix-components';
	import { isNullish, nonNullish } from '@dfinity/utils';
	import { type Snippet, createEventDispatcher, getContext, onMount } from 'svelte';
	import { run } from 'svelte/legacy';
	import BtcConvertForm from '$btc/components/convert/BtcConvertForm.svelte';
	import BtcConvertProgress from '$btc/components/convert/BtcConvertProgress.svelte';
	import BtcConvertReview from '$btc/components/convert/BtcConvertReview.svelte';
	import UtxosFeeContext from '$btc/components/fee/UtxosFeeContext.svelte';
	import { loadBtcPendingSentTransactions } from '$btc/services/btc-pending-sent-transactions.services';
	import { sendBtc } from '$btc/services/btc-send.services';
	import { UTXOS_FEE_CONTEXT_KEY } from '$btc/stores/utxos-fee.store';
	import { btcAddressStore } from '$icp/stores/btc.store';
	import ButtonBack from '$lib/components/ui/ButtonBack.svelte';
	import ButtonCancel from '$lib/components/ui/ButtonCancel.svelte';
	import {
		TRACK_COUNT_CONVERT_BTC_TO_CKBTC_ERROR,
		TRACK_COUNT_CONVERT_BTC_TO_CKBTC_SUCCESS
	} from '$lib/constants/analytics.contants';
	import {
		btcAddressMainnet,
		btcAddressRegtest,
		btcAddressTestnet
	} from '$lib/derived/address.derived';
	import { authIdentity } from '$lib/derived/auth.derived';
	import { ProgressStepsConvert } from '$lib/enums/progress-steps';
	import { WizardStepsConvert } from '$lib/enums/wizard-steps';
	import { trackEvent } from '$lib/services/analytics.services';
	import { nullishSignOut } from '$lib/services/auth.services';
	import { CONVERT_CONTEXT_KEY, type ConvertContext } from '$lib/stores/convert.store';
	import { i18n } from '$lib/stores/i18n.store';
	import { toastsError } from '$lib/stores/toasts.store';
	import type { NetworkId } from '$lib/types/network';
	import type { OptionAmount } from '$lib/types/send';
	import { invalidAmount, isNullishOrEmpty } from '$lib/utils/input.utils';
	import {
		isNetworkIdBTCRegtest,
		isNetworkIdBTCTestnet,
		mapNetworkIdToBitcoinNetwork
	} from '$lib/utils/network.utils';

	interface Props {
		currentStep: WizardStep | undefined;
		sendAmount: OptionAmount;
		receiveAmount: number | undefined;
		convertProgressStep: string;
		formCancelAction?: 'back' | 'close';
		children?: Snippet;
	}

	let {
		currentStep,
		sendAmount = $bindable(),
		receiveAmount = $bindable(),
		convertProgressStep = $bindable(),
		formCancelAction = 'close',
		children
	}: Props = $props();

	const { store: utxosFeeStore } = getContext<UtxosFeeContext>(UTXOS_FEE_CONTEXT_KEY);

	const { sourceToken, destinationToken } = getContext<ConvertContext>(CONVERT_CONTEXT_KEY);

	const progress = (step: ProgressStepsConvert) => (convertProgressStep = step);

	let amountError: boolean = $state();

	let networkId: NetworkId | undefined = $state(undefined);
	run(() => {
		networkId = $sourceToken.network.id;
	});

	let sourceAddress: string = $derived(
		(isNetworkIdBTCTestnet(networkId)
			? $btcAddressTestnet
			: isNetworkIdBTCRegtest(networkId)
				? $btcAddressRegtest
				: $btcAddressMainnet) ?? ''
	);

	let destinationAddress: string | undefined = $state(undefined);
	// BTC address generated by the ckBTC minter which needs to be used for BTC -> ckBTC conversion
	// Docs: https://github.com/dfinity/ic/blob/master/rs/bitcoin/ckbtc/minter/README.adoc#bitcoin-to-ckbtc
	run(() => {
		destinationAddress = $btcAddressStore?.[$destinationToken.id]?.data;
	});

	onMount(() => {
		loadBtcPendingSentTransactions({
			identity: $authIdentity,
			networkId,
			address: sourceAddress
		});
	});

	const dispatch = createEventDispatcher();

	const convert = async () => {
		const network = nonNullish(networkId) ? mapNetworkIdToBitcoinNetwork(networkId) : undefined;

		if (isNullish($authIdentity)) {
			await nullishSignOut();
			return;
		}

		// The data has been already validated in the previous conversion flow steps.
		if (
			isNullish(network) ||
			isNullishOrEmpty(destinationAddress) ||
			invalidAmount(sendAmount) ||
			isNullish(sendAmount) ||
			isNullish($utxosFeeStore?.utxosFee)
		) {
			toastsError({
				msg: { text: $i18n.convert.error.unexpected_missing_data }
			});
			return;
		}

		dispatch('icNext');

		try {
			await sendBtc({
				destination: destinationAddress,
				amount: sendAmount,
				utxosFee: $utxosFeeStore.utxosFee,
				network,
				source: sourceAddress,
				identity: $authIdentity,
				onProgress: () => {
					if (convertProgressStep === ProgressStepsConvert.INITIALIZATION) {
						progress(ProgressStepsConvert.CONVERT);
					} else if (convertProgressStep === ProgressStepsConvert.CONVERT) {
						progress(ProgressStepsConvert.UPDATE_UI);
					}
				}
			});

			progress(ProgressStepsConvert.DONE);

			trackEvent({
				name: TRACK_COUNT_CONVERT_BTC_TO_CKBTC_SUCCESS
			});

			setTimeout(() => close(), 750);
		} catch (err: unknown) {
			toastsError({
				msg: { text: $i18n.convert.error.unexpected },
				err
			});

			trackEvent({
				name: TRACK_COUNT_CONVERT_BTC_TO_CKBTC_ERROR
			});

			back();
		}
	};

	const close = () => dispatch('icClose');
	const back = () => dispatch('icBack');
</script>

<UtxosFeeContext amount={sendAmount} {amountError} {networkId} source={sourceAddress}>
	{#if currentStep?.name === WizardStepsConvert.CONVERT}
		<BtcConvertForm
			source={sourceAddress}
			on:icNext
			on:icClose
			bind:sendAmount
			bind:receiveAmount
			bind:amountError
		>
			{#snippet cancel()}
				{#if formCancelAction === 'back'}
					<ButtonBack onclick={back} />
				{:else}
					<ButtonCancel onclick={close} />
				{/if}
			{/snippet}
		</BtcConvertForm>
	{:else if currentStep?.name === WizardStepsConvert.REVIEW}
		<BtcConvertReview {receiveAmount} {sendAmount} on:icConvert={convert} on:icBack>
			{#snippet cancel()}
				<ButtonBack onclick={back} />
			{/snippet}
		</BtcConvertReview>
	{:else if currentStep?.name === WizardStepsConvert.CONVERTING}
		<BtcConvertProgress bind:convertProgressStep />
	{:else}
		{@render children?.()}
	{/if}
</UtxosFeeContext>
