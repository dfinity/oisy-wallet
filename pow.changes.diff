diff --git a/src/backend/src/lib.rs b/src/backend/src/lib.rs
index 5d77a4eec..dbedbaaf1 100644
--- a/src/backend/src/lib.rs
+++ b/src/backend/src/lib.rs
@@ -648,6 +648,23 @@ pub fn create_user_profile() -> UserProfile {
         let mut user_profile_model =
             UserProfileModel::new(&mut s.user_profile, &mut s.user_profile_updated);
         let stored_user = create_profile(stored_principal, &mut user_profile_model);
+
+        // TODO convert create_user_profile(..) to an asynchronous function and remove spawning the
+        // Spawn the async task for allow_signing after returning UserProfile synchronously
+        ic_cdk::spawn(async move {
+            // Upon initial user login, we have to that ensure allow_signing is called to handle
+            // cases where users lack the cycles required for signer operations. To
+            // guarantee correct functionality, create_user_profile(..) must be invoked
+            // before any signer-related calls (e.g., get_eth_address). Spawn the async
+            // task separately after returning UserProfile synchronously
+            if let Err(e) = signer::allow_signing(None).await {
+                ic_cdk::println!(
+                    "Error enabling signing for user {}: {:?}",
+                    stored_principal.0,
+                    e
+                );
+            }
+        });
         UserProfile::from(&stored_user)
     })
 }
@@ -731,7 +748,7 @@ pub async fn allow_signing(
 
     // Added for backward-compatibility to enforce old behaviour when feature flag POW_ENABLED is
     // disabled
-    if request.is_none() && !POW_ENABLED {
+    if !POW_ENABLED {
         // Passing None to apply the old cycle calculation logic
         signer::allow_signing(None).await?;
         // Returning a placeholder response that can be ignored by the frontend.
diff --git a/src/backend/src/pow.rs b/src/backend/src/pow.rs
index fa59ae30a..bd21f15fb 100644
--- a/src/backend/src/pow.rs
+++ b/src/backend/src/pow.rs
@@ -85,7 +85,6 @@ fn format_challenge(challenge: &StoredChallenge) -> String {
 // -------------------------------------------------------------------------------------------------
 // - Service functions
 // -------------------------------------------------------------------------------------------------
-
 pub async fn create_pow_challenge() -> Result<StoredChallenge, CreateChallengeError> {
     let user_principal = StoredPrincipal(caller());
     if !has_user_profile(user_principal) {
diff --git a/src/backend/tests/it/pow.rs b/src/backend/tests/it/pow.rs
index d62dda514..76a232342 100644
--- a/src/backend/tests/it/pow.rs
+++ b/src/backend/tests/it/pow.rs
@@ -1,6 +1,6 @@
 //! Tests the ledger account logic.
 
-use std::{thread, time::Duration};
+use std::time::Duration;
 
 use candid::Principal;
 use ic_cdk::api::management_canister::{main::canister_status, provisional::CanisterIdRecord};
@@ -49,16 +49,10 @@ fn print_canister_time(pic_setup: &PicBackend) {
         get_timestamp_secs(pic_setup.pic.get_time())
     );
 }
-fn sleep_test(duration: Duration) {
-    println!("Sleeping test task for {:?} ms", duration.as_millis());
-    thread::sleep(duration);
-}
-fn setup_cycles_ledger_with_progress() -> PicBackend {
+
+fn setup_with_cycles_ledger() -> PicBackend {
     eprintln!("Enabling auto progress for Pocket IC (Be aware that the cycle usage increases!");
-    let pic_setup = BackendBuilder::default()
-        .with_cycles_ledger(true)
-        .with_auto_progress(true)
-        .deploy();
+    let pic_setup = BackendBuilder::default().with_cycles_ledger(true).deploy();
     print_canister_time(&pic_setup);
     pic_setup
 }
@@ -221,7 +215,7 @@ fn test_create_pow_challenge_should_fail_without_user_profile() {
 
 #[test]
 fn test_create_pow_challenge_should_return_valid_values() {
-    let pic_setup = setup_cycles_ledger_with_progress();
+    let pic_setup = setup();
     let caller: Principal = Principal::from_text(CALLER).unwrap();
     let _ = call_create_user_profile(&pic_setup, caller);
 
@@ -235,7 +229,7 @@ fn test_create_pow_challenge_should_return_valid_values() {
 
 #[test]
 fn test_create_pow_challenge_should_succeed_again_if_expired() {
-    let pic_setup = setup_cycles_ledger_with_progress();
+    let pic_setup = setup();
 
     let caller: Principal = Principal::from_text(CALLER).unwrap();
     let _ = call_create_user_profile(&pic_setup, caller);
@@ -253,13 +247,15 @@ fn test_create_pow_challenge_should_succeed_again_if_expired() {
         .pic
         .advance_time(Duration::from_millis(expiry_ms - now_ms));
 
+    // pic_setup.pic.tick();
+
     let err_2th_call = call_create_pow_challenge(&pic_setup, caller);
     assert!(err_2th_call.is_ok());
 }
 
 #[test]
 fn test_create_pow_challenge_should_fail_if_not_expired() {
-    let pic_setup = setup_cycles_ledger_with_progress();
+    let pic_setup = setup();
     let caller: Principal = Principal::from_text(CALLER).unwrap();
     let _ = call_create_user_profile(&pic_setup, caller);
 
@@ -279,7 +275,7 @@ fn test_allow_signing_should_succeed_with_valid_nonce() {
     if !helper_is_pow_enabled() {
         return;
     }
-    let pic_setup = setup_cycles_ledger_with_progress();
+    let pic_setup = setup_with_cycles_ledger();
     let caller: Principal = Principal::from_text(CALLER).unwrap();
     let _ = call_create_user_profile(&pic_setup, caller);
 
@@ -308,7 +304,7 @@ fn test_allow_signing_with_valid_nonce_should_fail_when_called_more_than_once()
     if !helper_is_pow_enabled() {
         return;
     }
-    let pic_setup = setup_cycles_ledger_with_progress();
+    let pic_setup = setup_with_cycles_ledger();
     let caller: Principal = Principal::from_text(CALLER).unwrap();
     let _ = call_create_user_profile(&pic_setup, caller);
 
@@ -341,7 +337,7 @@ fn test_allow_signing_should_fail_with_valid_nonce_and_expired_challenge() {
     if !helper_is_pow_enabled() {
         return;
     }
-    let pic_setup = setup_cycles_ledger_with_progress();
+    let pic_setup = setup_with_cycles_ledger();
     let caller: Principal = Principal::from_text(CALLER).unwrap();
     let _ = call_create_user_profile(&pic_setup, caller);
 
@@ -358,8 +354,16 @@ fn test_allow_signing_should_fail_with_valid_nonce_and_expired_challenge() {
     // emulates the javascript function running in the browser to create a valid nonce
     let nonce = helper_solve_challenge(response.start_timestamp_ms, response.difficulty);
 
-    // since we enabled auto progress, we can not call pic.advance_time(..) instead we need to wait
-    thread::sleep(Duration::from_millis(expiry_ms - now_ms + 1000));
+    let now_ms = get_timestamp_ms(pic_setup.pic.get_time());
+    let expiry_ms = response.expiry_timestamp_ms;
+
+    assert_greater_than(expiry_ms, now_ms);
+
+    // we need advance to the expiry time of the challenge
+    pic_setup
+        .pic
+        .advance_time(Duration::from_millis(expiry_ms - now_ms));
+
     let result_allow_signing = call_allow_signing(&pic_setup, caller, nonce);
     assert!(result_allow_signing.is_err());
 }
@@ -369,7 +373,7 @@ fn test_allow_signing_should_fail_with_invalid_nonce() {
     if !helper_is_pow_enabled() {
         return;
     }
-    let pic_setup = setup_cycles_ledger_with_progress();
+    let pic_setup = setup_with_cycles_ledger();
     let caller: Principal = Principal::from_text(CALLER).unwrap();
     let _ = call_create_user_profile(&pic_setup, caller);
 
@@ -397,7 +401,7 @@ fn test_allow_signing_should_approve_the_correct_cycles_amount() {
         return;
     }
 
-    let pic_setup = setup_cycles_ledger_with_progress();
+    let pic_setup = setup_with_cycles_ledger();
     let caller: Principal = Principal::from_text(CALLER).unwrap();
     let _ = call_create_user_profile(&pic_setup, caller);
 
@@ -411,7 +415,7 @@ fn test_allow_signing_should_approve_the_correct_cycles_amount() {
     let result_allow_signing = call_allow_signing(&pic_setup, caller, nonce);
     assert!(result_allow_signing.is_ok());
     let response: AllowSigningResponse = result_allow_signing.unwrap();
-    assert_eq!(response.allowed_cycles, 1000000000);
+    assert_eq!(response.allowed_cycles, 7000000000);
     /*
     TODO uncomment this when the IC Pocker server supports an API to interact with the cycles ledger
     let backend_principle = pic_setup.canister_id;
@@ -431,7 +435,7 @@ fn test_pow_challenge_should_approach_target_duration_after_first_challenge() {
     if !helper_is_pow_enabled() {
         return;
     }
-    let pic_setup = setup_cycles_ledger_with_progress();
+    let pic_setup = setup_with_cycles_ledger();
     let caller: Principal = Principal::from_text(CALLER).unwrap();
     let _ = call_create_user_profile(&pic_setup, caller);
     // ---------------------------------------------------------------------------------------------
@@ -448,11 +452,15 @@ fn test_pow_challenge_should_approach_target_duration_after_first_challenge() {
         result_allow_signing_1.unwrap_err()
     );
 
-    // since we enabled auto progress, we can not call pic.advance_time(..) instead we need to wait
-    // instead
-    sleep_test(Duration::from_millis(
-        response_1.expiry_timestamp_ms - get_timestamp_ms(pic_setup.pic.get_time()) + 1000,
-    ));
+    let now_ms = get_timestamp_ms(pic_setup.pic.get_time());
+    let expiry_ms = response_1.expiry_timestamp_ms;
+    assert_greater_than(expiry_ms, now_ms);
+
+    // we need advance to the expiry time of the challenge
+    pic_setup
+        .pic
+        .advance_time(Duration::from_millis(expiry_ms - now_ms));
+
     // ---------------------------------------------------------------------------------------------
     // - Solve the second challenge and call allow_signing (using the adjusted difficulty)
     // ---------------------------------------------------------------------------------------------
@@ -461,7 +469,7 @@ fn test_pow_challenge_should_approach_target_duration_after_first_challenge() {
         result_2.expect("Failed to retrieve CreateChallengeResponse");
     let nonce_2 = helper_solve_challenge(response_2.start_timestamp_ms, response_2.difficulty);
     let result_allow_signing_2 = call_allow_signing(&pic_setup, caller, nonce_2);
-    debug_assert!(result_allow_signing_2.is_ok());
+    assert!(result_allow_signing_2.is_ok());
 
     let allow_signing_response_2 = result_allow_signing_2.unwrap();
     let challenge_completion = allow_signing_response_2
diff --git a/src/frontend/src/env/pow.env.ts b/src/frontend/src/env/pow.env.ts
new file mode 100644
index 000000000..573a6a195
--- /dev/null
+++ b/src/frontend/src/env/pow.env.ts
@@ -0,0 +1,4 @@
+export const POW_ENABLED = JSON.parse(import.meta.env.VITE_POW_ENABLED ?? false) === true;
+export const POW_CHALLENGE_INTERVAL_MILLIS: number = JSON.parse(
+	import.meta.env.VITE_POW_CHALLENGE_INTERVALL_MILLIS ?? 120000
+);
diff --git a/src/frontend/src/icp/schedulers/pow-protection.scheduler.ts b/src/frontend/src/icp/schedulers/pow-protection.scheduler.ts
new file mode 100644
index 000000000..19d2d4c10
--- /dev/null
+++ b/src/frontend/src/icp/schedulers/pow-protection.scheduler.ts
@@ -0,0 +1,60 @@
+import type { AllowSigningResponse, CreateChallengeResponse } from '$declarations/backend/backend.did';
+import { POW_CHALLENGE_INTERVAL_MILLIS } from '$env/pow.env';
+import { allowSigning, createPowChallenge } from '$lib/api/backend.api';
+import { type Scheduler, type SchedulerJobData, SchedulerTimer } from '$lib/schedulers/scheduler';
+import { solvePowChallenge } from '$lib/services/pow.services';
+import type { PostMessageDataRequest } from '$lib/types/post-message';
+import { toNullable } from '@dfinity/utils';
+
+export class PowProtectionScheduler implements Scheduler<PostMessageDataRequest> {
+	private timer = new SchedulerTimer('syncPowProtectionStatus');
+
+	private btcAddress: string | undefined;
+
+	stop() {
+		this.timer.stop();
+	}
+
+	async start(data: PostMessageDataRequest | undefined) {
+		await this.timer.start<PostMessageDataRequest>({
+			interval: POW_CHALLENGE_INTERVAL_MILLIS,
+			job: this.requestSignerCycles,
+			data
+		});
+	}
+
+	async trigger(data: PostMessageDataRequest | undefined) {
+		await this.timer.trigger<PostMessageDataRequest>({
+			job: this.requestSignerCycles,
+			data
+		});
+	}
+
+	/**
+	 * Initiates Proof-of-Work and signing processes sequentially.
+	 * This function coordinates:
+	 * 1. Creation of a PoW challenge.
+	 * 2. Solving the PoW challenge.
+	 * 3. Requesting allowance for signing using the solved nonce.
+	 *
+	 * Errors at any stage lead to early returns with appropriate logging.
+	 */
+	private requestSignerCycles = async ({ identity }: SchedulerJobData<PostMessageDataRequest>) => {
+		// Step 1: Requests creation of the Proof-of-Work (PoW) challenge and throws when unsuccessful.
+		const response: CreateChallengeResponse = await createPowChallenge({ identity });
+
+		// Step 2: Requests allowance for signing operations with solved nonce.
+		const nonce = await solvePowChallenge({
+			timestamp: response.start_timestamp_ms,
+			difficulty: response.difficulty
+		});
+
+		// Step 3: Requests allowance for signing operations with solved nonce.
+		const _allow_signing: AllowSigningResponse = await allowSigning({
+			identity,
+			nonce: toNullable(nonce)
+		});
+
+		// console.log('_allow_signing:', _allow_signing);
+	};
+}
diff --git a/src/frontend/src/icp/services/worker.pow-protection.services.ts b/src/frontend/src/icp/services/worker.pow-protection.services.ts
new file mode 100644
index 000000000..87d061194
--- /dev/null
+++ b/src/frontend/src/icp/services/worker.pow-protection.services.ts
@@ -0,0 +1,28 @@
+import type { PowProtectorWorkerInitResult } from '$icp/types/pow-protector-listener';
+import type { PostMessage, PostMessageDataResponse } from '$lib/types/post-message';
+
+export const initPowProtectorWorker = async (): Promise<PowProtectorWorkerInitResult> => {
+	const PowWorker = await import('$lib/workers/workers?worker');
+	const worker: Worker = new PowWorker.default();
+
+	worker.onmessage = ({ data: _data }: MessageEvent<PostMessage<PostMessageDataResponse>>) => {
+	};
+
+	return {
+		start: () => {
+			worker.postMessage({
+				msg: 'startPowProtectionTimer'
+			});
+		},
+		stop: () => {
+			worker.postMessage({
+				msg: 'stopPowProtectionTimer'
+			});
+		},
+		trigger: () => {
+			worker.postMessage({
+				msg: 'triggerPowProtectionTimer'
+			});
+		}
+	};
+};
diff --git a/src/frontend/src/icp/types/pow-protector-listener.ts b/src/frontend/src/icp/types/pow-protector-listener.ts
new file mode 100644
index 000000000..72f29e9ff
--- /dev/null
+++ b/src/frontend/src/icp/types/pow-protector-listener.ts
@@ -0,0 +1,7 @@
+export interface PowProtectorWorkerInitResult {
+	start: () => void;
+	stop: () => void;
+	trigger: () => void;
+}
+
+export type IcCkWorker = () => Promise<PowProtectorWorkerInitResult>;
diff --git a/src/frontend/src/icp/workers/pow-protection.worker.ts b/src/frontend/src/icp/workers/pow-protection.worker.ts
new file mode 100644
index 000000000..6c7c50b82
--- /dev/null
+++ b/src/frontend/src/icp/workers/pow-protection.worker.ts
@@ -0,0 +1,22 @@
+import { PowProtectionScheduler } from '$icp/schedulers/pow-protection.scheduler';
+import type { PostMessage, PostMessageDataRequest } from '$lib/types/post-message';
+
+const scheduler = new PowProtectionScheduler();
+
+export const onPowProtectionMessage = async ({
+																							 data: dataMsg
+																						 }: MessageEvent<PostMessage<PostMessageDataRequest>>) => {
+	const { msg, data } = dataMsg;
+
+	switch (msg) {
+		case 'stopPowProtectionTimer':
+			scheduler.stop();
+			return;
+		case 'startPowProtectionTimer':
+			await scheduler.start(data);
+			return;
+		case 'triggerPowProtectionTimer':
+			await scheduler.trigger(data);
+			return;
+	}
+};
diff --git a/src/frontend/src/lib/api/backend.api.ts b/src/frontend/src/lib/api/backend.api.ts
index e625bd20b..c7d195d77 100644
--- a/src/frontend/src/lib/api/backend.api.ts
+++ b/src/frontend/src/lib/api/backend.api.ts
@@ -1,5 +1,6 @@
 import type {
 	AllowSigningResponse,
+	CreateChallengeResponse,
 	CustomToken,
 	PendingTransaction,
 	SelectedUtxosFeeResponse,
@@ -13,11 +14,9 @@ import type {
 	AddUserCredentialResponse,
 	AddUserHiddenDappIdParams,
 	AllowSigningParams,
-	AllowSigningResult,
 	BtcAddPendingTransactionParams,
 	BtcGetPendingTransactionParams,
 	BtcSelectUserUtxosFeeParams,
-	CreateChallengeResult,
 	GetUserProfileResponse,
 	SaveUserNetworksSettings,
 	SetUserShowTestnetsParams
@@ -29,27 +28,27 @@ import { assertNonNullish, isNullish, type QueryParams } from '@dfinity/utils';
 let canister: BackendCanister | undefined = undefined;
 
 export const listUserTokens = async ({
-	identity,
-	certified
-}: CanisterApiFunctionParams<QueryParams>): Promise<UserToken[]> => {
+																			 identity,
+																			 certified
+																		 }: CanisterApiFunctionParams<QueryParams>): Promise<UserToken[]> => {
 	const { listUserTokens } = await backendCanister({ identity });
 
 	return listUserTokens({ certified });
 };
 
 export const listCustomTokens = async ({
-	identity,
-	certified
-}: CanisterApiFunctionParams<QueryParams>): Promise<CustomToken[]> => {
+																				 identity,
+																				 certified
+																			 }: CanisterApiFunctionParams<QueryParams>): Promise<CustomToken[]> => {
 	const { listCustomTokens } = await backendCanister({ identity });
 
 	return listCustomTokens({ certified });
 };
 
 export const setManyCustomTokens = async ({
-	identity,
-	tokens
-}: CanisterApiFunctionParams<{
+																						identity,
+																						tokens
+																					}: CanisterApiFunctionParams<{
 	tokens: CustomToken[];
 }>): Promise<void> => {
 	const { setManyCustomTokens } = await backendCanister({ identity });
@@ -58,9 +57,9 @@ export const setManyCustomTokens = async ({
 };
 
 export const setCustomToken = async ({
-	token,
-	identity
-}: CanisterApiFunctionParams<{
+																			 token,
+																			 identity
+																		 }: CanisterApiFunctionParams<{
 	token: CustomToken;
 }>): Promise<void> => {
 	const { setCustomToken } = await backendCanister({ identity });
@@ -69,18 +68,18 @@ export const setCustomToken = async ({
 };
 
 export const setManyUserTokens = async ({
-	identity,
-	tokens
-}: CanisterApiFunctionParams<{ tokens: UserToken[] }>): Promise<void> => {
+																					identity,
+																					tokens
+																				}: CanisterApiFunctionParams<{ tokens: UserToken[] }>): Promise<void> => {
 	const { setManyUserTokens } = await backendCanister({ identity });
 
 	return setManyUserTokens({ tokens });
 };
 
 export const setUserToken = async ({
-	token,
-	identity
-}: CanisterApiFunctionParams<{
+																		 token,
+																		 identity
+																	 }: CanisterApiFunctionParams<{
 	token: UserToken;
 }>): Promise<void> => {
 	const { setUserToken } = await backendCanister({ identity });
@@ -89,116 +88,106 @@ export const setUserToken = async ({
 };
 
 export const createUserProfile = async ({
-	identity
-}: CanisterApiFunctionParams): Promise<UserProfile> => {
+																					identity
+																				}: CanisterApiFunctionParams): Promise<UserProfile> => {
 	const { createUserProfile } = await backendCanister({ identity });
 
 	return createUserProfile();
 };
 
 export const getUserProfile = async ({
-	identity,
-	certified
-}: CanisterApiFunctionParams<QueryParams>): Promise<GetUserProfileResponse> => {
+																			 identity,
+																			 certified
+																		 }: CanisterApiFunctionParams<QueryParams>): Promise<GetUserProfileResponse> => {
 	const { getUserProfile } = await backendCanister({ identity });
 
 	return getUserProfile({ certified });
 };
 
 export const addUserCredential = async ({
-	identity,
-	...params
-}: CanisterApiFunctionParams<AddUserCredentialParams>): Promise<AddUserCredentialResponse> => {
+																					identity,
+																					...params
+																				}: CanisterApiFunctionParams<AddUserCredentialParams>): Promise<AddUserCredentialResponse> => {
 	const { addUserCredential } = await backendCanister({ identity });
 
 	return addUserCredential(params);
 };
 
 export const addPendingBtcTransaction = async ({
-	identity,
-	...params
-}: CanisterApiFunctionParams<BtcAddPendingTransactionParams>): Promise<boolean> => {
+																								 identity,
+																								 ...params
+																							 }: CanisterApiFunctionParams<BtcAddPendingTransactionParams>): Promise<boolean> => {
 	const { btcAddPendingTransaction } = await backendCanister({ identity });
 
 	return btcAddPendingTransaction(params);
 };
 
 export const getPendingBtcTransactions = async ({
-	identity,
-	...params
-}: CanisterApiFunctionParams<BtcGetPendingTransactionParams>): Promise<PendingTransaction[]> => {
+																									identity,
+																									...params
+																								}: CanisterApiFunctionParams<BtcGetPendingTransactionParams>): Promise<PendingTransaction[]> => {
 	const { btcGetPendingTransaction } = await backendCanister({ identity });
 
 	return btcGetPendingTransaction(params);
 };
 
 export const selectUserUtxosFee = async ({
-	identity,
-	...params
-}: CanisterApiFunctionParams<BtcSelectUserUtxosFeeParams>): Promise<SelectedUtxosFeeResponse> => {
+																					 identity,
+																					 ...params
+																				 }: CanisterApiFunctionParams<BtcSelectUserUtxosFeeParams>): Promise<SelectedUtxosFeeResponse> => {
 	const { btcSelectUserUtxosFee } = await backendCanister({ identity });
 
 	return btcSelectUserUtxosFee(params);
 };
 
 export const createPowChallenge = async ({
-	identity
-}: CanisterApiFunctionParams): Promise<CreateChallengeResult> => {
-	const { createPowChallengeResult } = await backendCanister({ identity });
-	return createPowChallengeResult();
+																					 identity
+																				 }: CanisterApiFunctionParams): Promise<CreateChallengeResponse> => {
+	const { createPowChallenge } = await backendCanister({ identity });
+	return createPowChallenge();
 };
 
 export const allowSigning = async ({
-	identity,
-	...params
-}: CanisterApiFunctionParams<AllowSigningParams>): Promise<AllowSigningResponse> => {
+																		 identity,
+																		 ...params
+																	 }: CanisterApiFunctionParams<AllowSigningParams>): Promise<AllowSigningResponse> => {
 	const { allowSigning } = await backendCanister({ identity });
 
-	return allowSigning(params);
-};
-
-export const allowSigningResult = async ({
-	identity,
-	...params
-}: CanisterApiFunctionParams<AllowSigningParams>): Promise<AllowSigningResult> => {
-	const { allowSigningResult } = await backendCanister({ identity });
-
-	// Conditionally call allowSigning with request or provide default logic
-	return allowSigningResult(params);
+	return allowSigning(params.nonce[0]);
 };
 
 export const addUserHiddenDappId = async ({
-	identity,
-	...params
-}: CanisterApiFunctionParams<AddUserHiddenDappIdParams>): Promise<void> => {
+																						identity,
+																						...params
+																					}: CanisterApiFunctionParams<AddUserHiddenDappIdParams>): Promise<void> => {
 	const { addUserHiddenDappId } = await backendCanister({ identity });
 
 	return addUserHiddenDappId(params);
 };
 
 export const setUserShowTestnets = async ({
-	identity,
-	...params
-}: CanisterApiFunctionParams<SetUserShowTestnetsParams>): Promise<void> => {
+																						identity,
+																						...params
+																					}: CanisterApiFunctionParams<SetUserShowTestnetsParams>): Promise<void> => {
 	const { setUserShowTestnets } = await backendCanister({ identity });
 
 	return setUserShowTestnets(params);
 };
 
 export const updateUserNetworkSettings = async ({
-	identity,
-	...params
-}: CanisterApiFunctionParams<SaveUserNetworksSettings>): Promise<void> => {
+																									identity,
+																									...params
+																								}: CanisterApiFunctionParams<SaveUserNetworksSettings>): Promise<void> => {
 	const { updateUserNetworkSettings } = await backendCanister({ identity });
 
 	return updateUserNetworkSettings(params);
 };
 
 const backendCanister = async ({
-	identity,
-	nullishIdentityErrorMessage,
-	canisterId = BACKEND_CANISTER_ID
-}: CanisterApiFunctionParams): Promise<BackendCanister> => {
+																 identity,
+																 nullishIdentityErrorMessage,
+																 canisterId = BACKEND_CANISTER_ID
+															 }: CanisterApiFunctionParams): Promise<BackendCanister> => {
 	assertNonNullish(identity, nullishIdentityErrorMessage);
 
 	if (isNullish(canister)) {
diff --git a/src/frontend/src/lib/canisters/backend.canister.ts b/src/frontend/src/lib/canisters/backend.canister.ts
index 5fecf477d..fd0961fc5 100644
--- a/src/frontend/src/lib/canisters/backend.canister.ts
+++ b/src/frontend/src/lib/canisters/backend.canister.ts
@@ -1,6 +1,7 @@
 import type {
-	AllowSigningResponse,
 	_SERVICE as BackendService,
+	AllowSigningResponse,
+	CreateChallengeResponse,
 	CustomToken,
 	PendingTransaction,
 	SelectedUtxosFeeResponse,
@@ -13,31 +14,29 @@ import { getAgent } from '$lib/actors/agents.ic';
 import {
 	mapAllowSigningError,
 	mapBtcPendingTransactionError,
-	mapBtcSelectUserUtxosFeeError
+	mapBtcSelectUserUtxosFeeError,
+	mapCreateChallengeError
 } from '$lib/canisters/backend.errors';
 import type {
 	AddUserCredentialParams,
 	AddUserCredentialResponse,
 	AddUserHiddenDappIdParams,
-	AllowSigningParams,
-	AllowSigningResult,
 	BtcAddPendingTransactionParams,
 	BtcGetPendingTransactionParams,
 	BtcSelectUserUtxosFeeParams,
-	CreateChallengeResult,
 	GetUserProfileResponse,
 	SaveUserNetworksSettings,
 	SetUserShowTestnetsParams
 } from '$lib/types/api';
 import type { CreateCanisterOptions } from '$lib/types/canister';
 import { mapUserNetworks } from '$lib/utils/user-networks.utils';
-import { Canister, createServices, toNullable, type QueryParams } from '@dfinity/utils';
+import { Canister, createServices, type QueryParams, toNullable } from '@dfinity/utils';
 
 export class BackendCanister extends Canister<BackendService> {
 	static async create({
-		identity,
-		...options
-	}: CreateCanisterOptions<BackendService>): Promise<BackendCanister> {
+												identity,
+												...options
+											}: CreateCanisterOptions<BackendService>): Promise<BackendCanister> {
 		const agent = await getAgent({ identity });
 
 		const { service, certifiedService, canisterId } = createServices<BackendService>({
@@ -101,11 +100,11 @@ export class BackendCanister extends Canister<BackendService> {
 	};
 
 	addUserCredential = ({
-		credentialJwt,
-		issuerCanisterId,
-		currentUserVersion,
-		credentialSpec
-	}: AddUserCredentialParams): Promise<AddUserCredentialResponse> => {
+												 credentialJwt,
+												 issuerCanisterId,
+												 currentUserVersion,
+												 credentialSpec
+											 }: AddUserCredentialParams): Promise<AddUserCredentialResponse> => {
 		const { add_user_credential } = this.caller({ certified: true });
 
 		return add_user_credential({
@@ -117,9 +116,9 @@ export class BackendCanister extends Canister<BackendService> {
 	};
 
 	btcAddPendingTransaction = async ({
-		txId,
-		...rest
-	}: BtcAddPendingTransactionParams): Promise<boolean> => {
+																			txId,
+																			...rest
+																		}: BtcAddPendingTransactionParams): Promise<boolean> => {
 		const { btc_add_pending_transaction } = this.caller({ certified: true });
 
 		const response = await btc_add_pending_transaction({
@@ -136,9 +135,9 @@ export class BackendCanister extends Canister<BackendService> {
 
 	// TODO: rename to plural
 	btcGetPendingTransaction = async ({
-		network,
-		address
-	}: BtcGetPendingTransactionParams): Promise<PendingTransaction[]> => {
+																			network,
+																			address
+																		}: BtcGetPendingTransactionParams): Promise<PendingTransaction[]> => {
 		const { btc_get_pending_transactions } = this.caller({ certified: true });
 
 		const response = await btc_get_pending_transactions({
@@ -157,10 +156,10 @@ export class BackendCanister extends Canister<BackendService> {
 	};
 
 	btcSelectUserUtxosFee = async ({
-		network,
-		minConfirmations,
-		amountSatoshis
-	}: BtcSelectUserUtxosFeeParams): Promise<SelectedUtxosFeeResponse> => {
+																	 network,
+																	 minConfirmations,
+																	 amountSatoshis
+																 }: BtcSelectUserUtxosFeeParams): Promise<SelectedUtxosFeeResponse> => {
 		const { btc_select_user_utxos_fee } = this.caller({ certified: true });
 
 		const response = await btc_select_user_utxos_fee({
@@ -177,33 +176,35 @@ export class BackendCanister extends Canister<BackendService> {
 		throw mapBtcSelectUserUtxosFeeError(response.Err);
 	};
 
-	// directly returning result and not the response
-	// TODO: check if this one is really needed because it may cause duplication of code with `allowSigningResult`
-	allowSigningResult = async ({ request }: AllowSigningParams): Promise<AllowSigningResult> => {
+	allowSigning = async (nonce?: bigint): Promise<AllowSigningResponse> => {
 		const { allow_signing } = this.caller({ certified: true });
-		return await allow_signing(toNullable(request));
-	};
 
-	allowSigning = async ({ request }: AllowSigningParams): Promise<AllowSigningResponse> => {
-		const response = await this.allowSigningResult({ request });
+		const result = await allow_signing(nonce !== undefined ? [{ nonce }] : []);
 
-		if ('Ok' in response) {
-			const { Ok } = response;
+		if ('Ok' in result) {
+			const { Ok } = result;
 			return Ok;
 		}
 
-		throw mapAllowSigningError(response.Err);
+		throw mapAllowSigningError(result.Err);
 	};
 
-	createPowChallengeResult = (): Promise<CreateChallengeResult> => {
+	createPowChallenge = async (): Promise<CreateChallengeResponse> => {
 		const { create_pow_challenge } = this.caller({ certified: true });
-		return create_pow_challenge();
+
+		const result = await create_pow_challenge();
+		if ('Ok' in result) {
+			const { Ok } = result;
+			return Ok;
+		}
+
+		throw mapCreateChallengeError(result.Err);
 	};
 
 	addUserHiddenDappId = async ({
-		dappId,
-		currentUserVersion
-	}: AddUserHiddenDappIdParams): Promise<void> => {
+																 dappId,
+																 currentUserVersion
+															 }: AddUserHiddenDappIdParams): Promise<void> => {
 		const { add_user_hidden_dapp_id } = this.caller({ certified: true });
 
 		await add_user_hidden_dapp_id({
@@ -213,9 +214,9 @@ export class BackendCanister extends Canister<BackendService> {
 	};
 
 	setUserShowTestnets = async ({
-		showTestnets,
-		currentUserVersion
-	}: SetUserShowTestnetsParams): Promise<void> => {
+																 showTestnets,
+																 currentUserVersion
+															 }: SetUserShowTestnetsParams): Promise<void> => {
 		const { set_user_show_testnets } = this.caller({ certified: true });
 
 		await set_user_show_testnets({
@@ -225,9 +226,9 @@ export class BackendCanister extends Canister<BackendService> {
 	};
 
 	updateUserNetworkSettings = async ({
-		networks,
-		currentUserVersion
-	}: SaveUserNetworksSettings): Promise<void> => {
+																			 networks,
+																			 currentUserVersion
+																		 }: SaveUserNetworksSettings): Promise<void> => {
 		const { update_user_network_settings } = this.caller({ certified: true });
 
 		await update_user_network_settings({
diff --git a/src/frontend/src/lib/canisters/backend.errors.ts b/src/frontend/src/lib/canisters/backend.errors.ts
index c9af3ec38..e529865c6 100644
--- a/src/frontend/src/lib/canisters/backend.errors.ts
+++ b/src/frontend/src/lib/canisters/backend.errors.ts
@@ -2,10 +2,11 @@ import type {
 	AllowSigningError,
 	BtcAddPendingTransactionError,
 	ChallengeCompletionError,
+	CreateChallengeError,
 	SelectedUtxosFeeError
 } from '$declarations/backend/backend.did';
 import { CanisterInternalError } from '$lib/canisters/errors';
-import { mapIcrc2ApproveError, type ApproveError } from '@dfinity/ledger-icp';
+import { type ApproveError, mapIcrc2ApproveError } from '@dfinity/ledger-icp';
 
 export const mapBtcPendingTransactionError = (
 	err: BtcAddPendingTransactionError
@@ -54,3 +55,23 @@ export const mapAllowSigningError = (
 
 	return new CanisterInternalError('Unknown AllowSigningError');
 };
+
+export const mapCreateChallengeError = (err: CreateChallengeError): CanisterInternalError => {
+	if ('ChallengeInProgress' in err) {
+		return new CanisterInternalError('Challenge is already in progress.');
+	}
+
+	if ('MissingUserProfile' in err) {
+		return new CanisterInternalError('User profile is missing.');
+	}
+
+	if ('RandomnessError' in err) {
+		return new CanisterInternalError(err.RandomnessError);
+	}
+
+	if ('Other' in err) {
+		return new CanisterInternalError(err.Other);
+	}
+
+	return new CanisterInternalError('Unknown CreateChallengeError');
+};
diff --git a/src/frontend/src/lib/components/guard/AddressGuard.svelte b/src/frontend/src/lib/components/guard/AddressGuard.svelte
index 4e78d9420..094c8a319 100644
--- a/src/frontend/src/lib/components/guard/AddressGuard.svelte
+++ b/src/frontend/src/lib/components/guard/AddressGuard.svelte
@@ -1,5 +1,6 @@
 <script lang="ts">
 	import { validateBtcAddressMainnet } from '$btc/services/btc-address.services';
+	import { POW_ENABLED } from '$env/pow.env';
 	import { validateEthAddress } from '$eth/services/eth-address.services';
 	import {
 		networkBitcoinMainnetEnabled,
@@ -7,21 +8,19 @@
 		networkSolanaMainnetEnabled
 	} from '$lib/derived/networks.derived';
 	import { initSignerAllowance } from '$lib/services/loader.services';
-	import {
-		btcAddressMainnetStore,
-		ethAddressStore,
-		solAddressMainnetStore
-	} from '$lib/stores/address.store';
+	import { btcAddressMainnetStore, ethAddressStore, solAddressMainnetStore } from '$lib/stores/address.store';
 	import { validateSolAddressMainnet } from '$sol/services/sol-address.services';
 
 	let signerAllowanceLoaded = false;
 
 	const loadSignerAllowanceAndValidateAddresses = async () => {
-		const { success: initSignerAllowanceSuccess } = await initSignerAllowance();
+		if (!POW_ENABLED) {
+			const { success: initSignerAllowanceSuccess } = await initSignerAllowance();
 
-		if (!initSignerAllowanceSuccess) {
-			// Sign-out is handled within the service.
-			return;
+			if (!initSignerAllowanceSuccess) {
+				// Sign-out is handled within the service.
+				return;
+			}
 		}
 
 		signerAllowanceLoaded = true;
diff --git a/src/frontend/src/lib/components/loaders/Loaders.svelte b/src/frontend/src/lib/components/loaders/Loaders.svelte
index cdb28338a..e26cb44e1 100644
--- a/src/frontend/src/lib/components/loaders/Loaders.svelte
+++ b/src/frontend/src/lib/components/loaders/Loaders.svelte
@@ -9,29 +9,32 @@
 	import LoaderMetamask from '$lib/components/loaders/LoaderMetamask.svelte';
 	import LoaderUserProfile from '$lib/components/loaders/LoaderUserProfile.svelte';
 	import LoaderWallets from '$lib/components/loaders/LoaderWallets.svelte';
+	import PowProtector from '$lib/components/pow/PowProtector.svelte';
 	import UserSnapshotWorker from '$lib/components/rewards/UserSnapshotWorker.svelte';
 </script>
 
 <LoaderUserProfile>
-	<AddressGuard>
-		<Loader>
-			<UrlGuard>
-				<RewardGuard>
-					<LoaderEthBalances>
-						<LoaderWallets>
-							<ExchangeWorker>
-								<LoaderMetamask>
-									<UserSnapshotWorker>
-										<slot />
-									</UserSnapshotWorker>
-								</LoaderMetamask>
-							</ExchangeWorker>
-						</LoaderWallets>
-					</LoaderEthBalances>
-				</RewardGuard>
-			</UrlGuard>
-		</Loader>
-	</AddressGuard>
+	<PowProtector>
+		<AddressGuard>
+			<Loader>
+				<UrlGuard>
+					<RewardGuard>
+						<LoaderEthBalances>
+							<LoaderWallets>
+								<ExchangeWorker>
+									<LoaderMetamask>
+										<UserSnapshotWorker>
+											<slot />
+										</UserSnapshotWorker>
+									</LoaderMetamask>
+								</ExchangeWorker>
+							</LoaderWallets>
+						</LoaderEthBalances>
+					</RewardGuard>
+				</UrlGuard>
+			</Loader>
+		</AddressGuard>
+	</PowProtector>
 </LoaderUserProfile>
 
 <!-- This listener is kept outside of the Loaders tree to prevent slow page loading on localhost/e2e -->
diff --git a/src/frontend/src/lib/components/pow/PowProtector.svelte b/src/frontend/src/lib/components/pow/PowProtector.svelte
new file mode 100644
index 000000000..c7ee5df60
--- /dev/null
+++ b/src/frontend/src/lib/components/pow/PowProtector.svelte
@@ -0,0 +1,21 @@
+<script lang="ts">
+	import { onDestroy, onMount } from 'svelte';
+	import { POW_ENABLED } from '$env/pow.env';
+	import { initPowProtectorWorker } from '$icp/services/worker.pow-protection.services';
+	import type { PowProtectorWorkerInitResult } from '$icp/types/pow-protector-listener';
+
+	if (POW_ENABLED) {
+		let powWorker: PowProtectorWorkerInitResult;
+
+		onMount(async () => {
+			// Initialize the worker
+			powWorker = await initPowProtectorWorker();
+			// Start the worker
+			powWorker.start();
+		});
+
+		onDestroy(() => powWorker?.stop());
+	}
+</script>
+
+<slot />
diff --git a/src/frontend/src/lib/schema/post-message.schema.ts b/src/frontend/src/lib/schema/post-message.schema.ts
index 8736bc175..7e70ea2c6 100644
--- a/src/frontend/src/lib/schema/post-message.schema.ts
+++ b/src/frontend/src/lib/schema/post-message.schema.ts
@@ -1,19 +1,12 @@
 import type { Erc20ContractAddress } from '$eth/types/erc20';
-import {
-	IcCanistersSchema,
-	IcCanistersStrictSchema,
-	IcCkMetadataSchema
-} from '$icp/schema/ic-token.schema';
+import { IcCanistersSchema, IcCanistersStrictSchema, IcCkMetadataSchema } from '$icp/schema/ic-token.schema';
 import type { BtcAddressData } from '$icp/stores/btc.store';
 import type { JsonText } from '$icp/types/btc.post-message';
 import { NetworkSchema } from '$lib/schema/network.schema';
 import { SyncStateSchema } from '$lib/schema/sync.schema';
 import type { BtcAddress, SolAddress } from '$lib/types/address';
 import { CanisterIdTextSchema, type OptionCanisterIdText } from '$lib/types/canister';
-import type {
-	CoingeckoSimplePriceResponse,
-	CoingeckoSimpleTokenPriceResponse
-} from '$lib/types/coingecko';
+import type { CoingeckoSimplePriceResponse, CoingeckoSimpleTokenPriceResponse } from '$lib/types/coingecko';
 import type { CertifiedData } from '$lib/types/store';
 import type { SolanaNetworkType } from '$sol/types/network';
 import type { SplTokenAddress } from '$sol/types/spl';
@@ -27,6 +20,9 @@ export const PostMessageRequestSchema = z.enum([
 	'stopCodeTimer',
 	'startExchangeTimer',
 	'stopExchangeTimer',
+	'startPowProtectionTimer',
+	'triggerPowProtectionTimer',
+	'stopPowProtectionTimer',
 	'stopIcpWalletTimer',
 	'startIcpWalletTimer',
 	'triggerIcpWalletTimer',
@@ -104,7 +100,8 @@ export const PostMessageResponseStatusSchema = z.enum([
 	'syncSolWalletStatus',
 	'syncBtcStatusesStatus',
 	'syncCkMinterInfoStatus',
-	'syncCkBTCUpdateBalanceStatus'
+	'syncCkBTCUpdateBalanceStatus',
+	'syncPowProtectionStatus'
 ]);
 
 export const PostMessageResponseSchema = z.enum([
@@ -129,6 +126,7 @@ export const PostMessageResponseSchema = z.enum([
 	'syncBtcPendingUtxos',
 	'syncCkBTCUpdateOk',
 	'syncBtcAddress',
+	'syncPowProtection',
 	...PostMessageResponseStatusSchema.options
 ]);
 
diff --git a/src/frontend/src/lib/services/loader.services.ts b/src/frontend/src/lib/services/loader.services.ts
index a4e528433..a3f0d87c5 100644
--- a/src/frontend/src/lib/services/loader.services.ts
+++ b/src/frontend/src/lib/services/loader.services.ts
@@ -1,3 +1,4 @@
+import { POW_ENABLED } from '$env/pow.env';
 import { allowSigning } from '$lib/api/backend.api';
 import { loadAddresses, loadIdbAddresses } from '$lib/services/addresses.services';
 import { errorSignOut, nullishSignOut, signOut } from '$lib/services/auth.services';
@@ -30,7 +31,10 @@ export const initSignerAllowance = async (): Promise<ResultSuccess> => {
 	try {
 		const { identity } = get(authStore);
 
-		await allowSigning({ identity });
+		await allowSigning({
+			identity,
+			nonce: [] // Default empty nonce
+		});
 	} catch (_err: unknown) {
 		// In the event of any error, we sign the user out, as we assume that the Oisy Wallet cannot function without ETH or Bitcoin addresses.
 		await errorSignOut(get(i18n).init.error.allow_signing);
@@ -62,11 +66,11 @@ export const initSignerAllowance = async (): Promise<ResultSuccess> => {
  * @returns {Promise<void>} Returns a promise that resolves when the loader is correctly initialized (user profile settings and addresses are loaded).
  */
 export const initLoader = async ({
-	identity,
-	validateAddresses,
-	progressAndLoad,
-	setProgressModal
-}: {
+																	 identity,
+																	 validateAddresses,
+																	 progressAndLoad,
+																	 setProgressModal
+																 }: {
 	identity: OptionIdentity;
 	validateAddresses: () => void;
 	progressAndLoad: () => Promise<void>;
@@ -100,14 +104,14 @@ export const initLoader = async ({
 
 	// We are loading the addresses from the backend. Consequently, we aim to animate this operation and offer the user an explanation of what is happening. To achieve this, we will present this information within a modal.
 	setProgressModal(true);
+	if (!POW_ENABLED) {
+		const { success: initSignerAllowanceSuccess } = await initSignerAllowance();
 
-	const { success: initSignerAllowanceSuccess } = await initSignerAllowance();
-
-	if (!initSignerAllowanceSuccess) {
-		// Sign-out is handled within the service.
-		return;
+		if (!initSignerAllowanceSuccess) {
+			// Sign-out is handled within the service.
+			return;
+		}
 	}
-
 	const { success: addressSuccess } = await loadAddresses(
 		err?.map(({ networkId }) => networkId) ?? []
 	);
diff --git a/src/frontend/src/lib/services/pow.services.ts b/src/frontend/src/lib/services/pow.services.ts
new file mode 100644
index 000000000..ced31854f
--- /dev/null
+++ b/src/frontend/src/lib/services/pow.services.ts
@@ -0,0 +1,53 @@
+import { hashToHex } from '$lib/utils/crypto.utils';
+
+/**
+ * Solves a Proof-of-Work (PoW) challenge by finding a `nonce` that satisfies the given difficulty level.
+ *
+ * The PoW challenge involves concatenating a `timestamp` with a `nonce` and hashing the resulting string.
+ * The goal is to find a `nonce` such that the first 4 bytes of the hash, when interpreted as an integer, are
+ * less or equal to the calculated `target`. based on the difficulty level.
+ *
+ * For a better understanding the difficulty level influences the challenge:
+ * - Higher difficulty ⇒ smaller target ⇒ harder challenge (fewer valid hashes).
+ * - Lower difficulty ⇒ larger target ⇒ easier challenge (more valid hashes).
+ */
+export const solvePowChallenge = async ({
+																					timestamp,
+																					difficulty
+																				}: {
+	timestamp: bigint; // The unique timestamp for the challenge
+	difficulty: number; // The difficulty level
+}): Promise<bigint> => {
+	if (difficulty <= 0) {
+		throw new Error('Difficulty must be greater than zero');
+	}
+
+	// This is the value we need to find to solve the challenge (changed to bigint)
+	let nonce = 0n;
+
+	// Target is proportional to 1/difficulty (converted target to bigint)
+	const target = BigInt(Math.floor(0xffffffff / difficulty));
+
+	// Continuously try different nonce values until the challenge is solved
+	while (true) {
+		// Concatenate the timestamp and nonce as the challenge string
+		const challengeStr = `${timestamp}.${nonce}`;
+
+		// Hash the string into a hex representation
+		const hashHex = await hashToHex(challengeStr);
+
+		// Extract the first 4 bytes of the hash as a number (prefix converted to bigint)
+		const prefix = BigInt(parseInt(hashHex.slice(0, 8), 16));
+
+		// If the prefix satisfies the difficulty target, stop the loop
+		if (prefix <= target) {
+			break;
+		}
+
+		// Otherwise, increment the nonce (bigint increment) and try again
+		nonce++;
+	}
+
+	// Return the nonce that solves the challenge (bigint type)
+	return nonce;
+};
diff --git a/src/frontend/src/lib/types/api.ts b/src/frontend/src/lib/types/api.ts
index db1f96663..6ad1ca667 100644
--- a/src/frontend/src/lib/types/api.ts
+++ b/src/frontend/src/lib/types/api.ts
@@ -1,11 +1,6 @@
 import type {
 	AddUserCredentialError,
-	AllowSigningError,
-	AllowSigningRequest,
-	AllowSigningResponse,
 	BitcoinNetwork,
-	CreateChallengeError,
-	CreateChallengeResponse,
 	CredentialSpec,
 	GetUserProfileError,
 	UserProfile,
@@ -13,9 +8,9 @@ import type {
 } from '$declarations/backend/backend.did';
 import type { TxId } from '$declarations/kong_backend/kong_backend.did';
 import type {
+	BitcoinNetwork as SignerBitcoinNetwork,
 	BtcTxOutput,
 	SchnorrKeyId,
-	BitcoinNetwork as SignerBitcoinNetwork,
 	Utxo as SignerUtxo
 } from '$declarations/signer/signer.did';
 import type { Address, BtcAddress } from '$lib/types/address';
@@ -34,9 +29,9 @@ export type AddUserCredentialResponse = { Ok: null } | { Err: AddUserCredentialE
 
 export type GetUserProfileResponse = { Ok: UserProfile } | { Err: GetUserProfileError };
 
-export type AllowSigningResult = { Ok: AllowSigningResponse } | { Err: AllowSigningError };
-
-export type CreateChallengeResult = { Ok: CreateChallengeResponse } | { Err: CreateChallengeError };
+export interface AllowSigningParams {
+	nonce: [] | [bigint];
+}
 
 export interface BtcSelectUserUtxosFeeParams {
 	network: BitcoinNetwork;
@@ -101,7 +96,3 @@ export interface KongSwapParams {
 	sourceToken: Token;
 	payTransactionId?: TxId;
 }
-
-export interface AllowSigningParams {
-	request?: AllowSigningRequest;
-}
diff --git a/src/frontend/src/lib/types/post-message.ts b/src/frontend/src/lib/types/post-message.ts
index 4149fbe2b..16a0c113e 100644
--- a/src/frontend/src/lib/types/post-message.ts
+++ b/src/frontend/src/lib/types/post-message.ts
@@ -1,25 +1,25 @@
-import type {
-	PostMessageDataRequestBtcSchema,
-	PostMessageDataRequestExchangeTimerSchema,
-	PostMessageDataRequestIcCkBTCUpdateBalanceSchema,
-	PostMessageDataRequestIcCkSchema,
-	PostMessageDataRequestIcrcSchema,
-	PostMessageDataRequestIcrcStrictSchema,
-	PostMessageDataRequestSchema,
-	PostMessageDataRequestSolSchema,
-	PostMessageDataResponseAuthSchema,
-	PostMessageDataResponseBTCAddressSchema,
-	PostMessageDataResponseErrorSchema,
-	PostMessageDataResponseExchangeErrorSchema,
-	PostMessageDataResponseExchangeSchema,
-	PostMessageDataResponseSchema,
-	PostMessageDataResponseWalletCleanUpSchema,
-	PostMessageDataResponseWalletSchema,
-	PostMessageJsonDataResponseSchema,
-	PostMessageResponseSchema,
-	PostMessageResponseStatusSchema,
-	PostMessageSyncStateSchema,
-	inferPostMessageSchema
+import {
+	type inferPostMessageSchema,
+	type PostMessageDataRequestBtcSchema,
+	type PostMessageDataRequestExchangeTimerSchema,
+	type PostMessageDataRequestIcCkBTCUpdateBalanceSchema,
+	type PostMessageDataRequestIcCkSchema,
+	type PostMessageDataRequestIcrcSchema,
+	type PostMessageDataRequestIcrcStrictSchema,
+	type PostMessageDataRequestSchema,
+	type PostMessageDataRequestSolSchema,
+	type PostMessageDataResponseAuthSchema,
+	type PostMessageDataResponseBTCAddressSchema,
+	type PostMessageDataResponseErrorSchema,
+	type PostMessageDataResponseExchangeErrorSchema,
+	type PostMessageDataResponseExchangeSchema,
+	type PostMessageDataResponseSchema,
+	type PostMessageDataResponseWalletCleanUpSchema,
+	type PostMessageDataResponseWalletSchema,
+	type PostMessageJsonDataResponseSchema,
+	type PostMessageResponseSchema,
+	type PostMessageResponseStatusSchema,
+	type PostMessageSyncStateSchema
 } from '$lib/schema/post-message.schema';
 import type * as z from 'zod';
 import type { ZodType } from 'zod';
diff --git a/src/frontend/src/lib/utils/crypto.utils.ts b/src/frontend/src/lib/utils/crypto.utils.ts
new file mode 100644
index 000000000..3a08bd129
--- /dev/null
+++ b/src/frontend/src/lib/utils/crypto.utils.ts
@@ -0,0 +1,25 @@
+const textEncoder = new TextEncoder();
+
+/**
+ * Hashes the given input string using the SHA-256 algorithm.
+ */
+export async function sha256(input: string): Promise<ArrayBuffer> {
+	return await crypto.subtle.digest('SHA-256', textEncoder.encode(input));
+}
+
+/**
+ * Converts an ArrayBuffer to its hexadecimal string representation.
+ */
+export function bufferToHex(buffer: ArrayBuffer): string {
+	return Array.from(new Uint8Array(buffer))
+		.map((byte) => byte.toString(16).padStart(2, '0'))
+		.join('');
+}
+
+/**
+ * Combines the hashing and hex conversion of a string into a single function.
+ */
+export async function hashToHex(input: string): Promise<string> {
+	const hashBuffer = await sha256(input);
+	return bufferToHex(hashBuffer);
+}
diff --git a/src/frontend/src/lib/workers/workers.ts b/src/frontend/src/lib/workers/workers.ts
index eaf40fbde..0bec645a7 100644
--- a/src/frontend/src/lib/workers/workers.ts
+++ b/src/frontend/src/lib/workers/workers.ts
@@ -5,6 +5,7 @@ import { onCkBtcUpdateBalanceMessage } from '$icp/workers/ckbtc-update-balance.w
 import { onCkEthMinterInfoMessage } from '$icp/workers/cketh-minter-info.worker';
 import { onIcpWalletMessage } from '$icp/workers/icp-wallet.worker';
 import { onIcrcWalletMessage } from '$icp/workers/icrc-wallet.worker';
+import { onPowProtectionMessage } from '$icp/workers/pow-protection.worker';
 import type { PostMessage, PostMessageDataRequest } from '$lib/types/post-message';
 import { onAuthMessage } from '$lib/workers/auth.worker';
 import { onExchangeMessage } from '$lib/workers/exchange.worker';
@@ -21,6 +22,7 @@ onmessage = async (msg: MessageEvent<PostMessage<PostMessageDataRequest>>) => {
 		onCkEthMinterInfoMessage(msg),
 		onIcpWalletMessage(msg),
 		onIcrcWalletMessage(msg),
-		onSolWalletMessage(msg)
+		onSolWalletMessage(msg),
+		onPowProtectionMessage(msg)
 	]);
 };
diff --git a/src/frontend/src/tests/lib/canisters/backend.canister.spec.ts b/src/frontend/src/tests/lib/canisters/backend.canister.spec.ts
index 9862d8388..62af6bda1 100644
--- a/src/frontend/src/tests/lib/canisters/backend.canister.spec.ts
+++ b/src/frontend/src/tests/lib/canisters/backend.canister.spec.ts
@@ -1,6 +1,5 @@
 import type {
 	_SERVICE as BackendService,
-	CreateChallengeResponse,
 	CustomToken,
 	IcrcToken,
 	Result_2,
@@ -33,8 +32,8 @@ vi.mock(import('$lib/constants/app.constants'), async (importOriginal) => {
 
 describe('backend.canister', () => {
 	const createBackendCanister = ({
-		serviceOverride
-	}: Pick<CreateCanisterOptions<BackendService>, 'serviceOverride'>): Promise<BackendCanister> =>
+																	 serviceOverride
+																 }: Pick<CreateCanisterOptions<BackendService>, 'serviceOverride'>): Promise<BackendCanister> =>
 		BackendCanister.create({
 			canisterId: Principal.fromText('tdxud-2yaaa-aaaad-aadiq-cai'),
 			identity: mockIdentity,
@@ -625,7 +624,7 @@ describe('backend.canister', () => {
 				serviceOverride: service
 			});
 
-			const res = await allowSigning({});
+			const res = await allowSigning();
 
 			expect(service.allow_signing).toHaveBeenCalledTimes(1);
 			expect(res).toBeDefined();
@@ -641,7 +640,7 @@ describe('backend.canister', () => {
 				serviceOverride: service
 			});
 
-			const res = allowSigning({});
+			const res = allowSigning();
 
 			await expect(res).rejects.toThrow(mockResponseError);
 		});
@@ -659,9 +658,7 @@ describe('backend.canister', () => {
 				serviceOverride: service
 			});
 
-			await expect(allowSigning({})).rejects.toThrow(
-				mapIcrc2ApproveError(response.Err.ApproveError)
-			);
+			await expect(allowSigning()).rejects.toThrow(mapIcrc2ApproveError(response.Err.ApproveError));
 		});
 
 		it('should throw a CanisterInternalError if FailedToContactCyclesLedger error is returned', async () => {
@@ -673,7 +670,7 @@ describe('backend.canister', () => {
 				serviceOverride: service
 			});
 
-			await expect(allowSigning({})).rejects.toThrow(
+			await expect(allowSigning()).rejects.toThrow(
 				new CanisterInternalError('The Cycles Ledger cannot be contacted.')
 			);
 		});
@@ -688,7 +685,7 @@ describe('backend.canister', () => {
 				serviceOverride: service
 			});
 
-			await expect(allowSigning({})).rejects.toThrow(new CanisterInternalError(errorMsg));
+			await expect(allowSigning()).rejects.toThrow(new CanisterInternalError(errorMsg));
 		});
 
 		it('should throw an unknown AllowSigningError if unrecognized error is returned', async () => {
@@ -700,120 +697,80 @@ describe('backend.canister', () => {
 				serviceOverride: service
 			});
 
-			await expect(allowSigning({})).rejects.toThrow(
+			await expect(allowSigning()).rejects.toThrow(
 				new CanisterInternalError('Unknown AllowSigningError')
 			);
 		});
 	});
 
 	describe('createPowChallenge', () => {
-		const mockPowChallengeSuccess: CreateChallengeResponse = {
+		const mockPowChallengeSuccess = {
 			start_timestamp_ms: 1_644_001_000_000n,
 			expiry_timestamp_ms: 1_644_001_001_200n,
 			difficulty: 1_000_000
 		};
 
+		let backendCanister: BackendCanister;
+
+		beforeEach(async () => {
+			backendCanister = await createBackendCanister({ serviceOverride: service });
+		});
+
 		it('should successfully create a PoW challenge (Ok case)', async () => {
 			service.create_pow_challenge.mockResolvedValue({ Ok: mockPowChallengeSuccess });
 
-			const backendCanister = await createBackendCanister({ serviceOverride: service });
-
-			const result = await backendCanister.createPowChallengeResult();
+			const result = await backendCanister.createPowChallenge();
 
 			expect(service.create_pow_challenge).toHaveBeenCalled();
-
-			if ('Ok' in result) {
-				expect(result.Ok).toEqual(mockPowChallengeSuccess);
-			} else {
-				throw new Error(`Unexpected error: ${JSON.stringify(result.Err)}`);
-			}
+			expect(result).toEqual(mockPowChallengeSuccess);
 		});
 
-		test('should handle challenge already in progress error', async () => {
+		it('should handle challenge already in progress error', async () => {
 			service.create_pow_challenge.mockResolvedValue({
 				Err: { ChallengeInProgress: null }
 			});
 
-			const backendCanister = await createBackendCanister({ serviceOverride: service });
-
-			const result = await backendCanister.createPowChallengeResult();
+			await expect(backendCanister.createPowChallenge()).rejects.toThrowError(
+				'Challenge is already in progress.'
+			);
 
-			expect(result).toEqual({ Err: { ChallengeInProgress: null } });
+			expect(service.create_pow_challenge).toHaveBeenCalled();
 		});
 
-		test('should handle randomness generation error', async () => {
+		it('should handle randomness generation error', async () => {
 			service.create_pow_challenge.mockResolvedValue({
 				Err: { RandomnessError: 'Failed to generate randomness' }
 			});
 
-			const backendCanister = await createBackendCanister({ serviceOverride: service });
-
-			const result = await backendCanister.createPowChallengeResult();
+			await expect(backendCanister.createPowChallenge()).rejects.toThrowError(
+				'Failed to generate randomness'
+			);
 
-			expect(result).toEqual({
-				Err: { RandomnessError: 'Failed to generate randomness' }
-			});
+			expect(service.create_pow_challenge).toHaveBeenCalled();
 		});
 
 		it('should handle missing user profile error', async () => {
-			service.create_pow_challenge.mockResolvedValue({ Err: { MissingUserProfile: null } });
-
-			const backendCanister = await createBackendCanister({ serviceOverride: service });
-
-			const result = await backendCanister.createPowChallengeResult();
-
-			expect(result).toEqual({ Err: { MissingUserProfile: null } });
-
-			expect(service.create_pow_challenge).toHaveBeenCalledTimes(1);
-		});
-
-		it('should handle unexpected errors in result', async () => {
 			service.create_pow_challenge.mockResolvedValue({
-				Err: { Other: 'Unexpected error occurred.' }
+				Err: { MissingUserProfile: null }
 			});
 
-			const backendCanister = await createBackendCanister({ serviceOverride: service });
-
-			const result = await backendCanister.createPowChallengeResult();
-
-			expect(result).toEqual({ Err: { Other: 'Unexpected error occurred.' } });
-
-			expect(service.create_pow_challenge).toHaveBeenCalledTimes(1);
-		});
-	});
-
-	describe('addUserHiddenDappId', () => {
-		it('should add user hidden dapp id', async () => {
-			const response = { Ok: null };
-
-			service.add_user_hidden_dapp_id.mockResolvedValue(response);
-
-			const { addUserHiddenDappId } = await createBackendCanister({
-				serviceOverride: service
-			});
-
-			const res = await addUserHiddenDappId({ dappId: 'test-dapp-id' });
+			await expect(backendCanister.createPowChallenge()).rejects.toThrowError(
+				'User profile is missing.'
+			);
 
-			expect(service.add_user_hidden_dapp_id).toHaveBeenCalledWith({
-				dapp_id: 'test-dapp-id',
-				current_user_version: []
-			});
-			expect(res).toBeUndefined();
+			expect(service.create_pow_challenge).toHaveBeenCalled();
 		});
 
-		it('should throw an error if add_user_hidden_dapp_id throws', async () => {
-			service.add_user_hidden_dapp_id.mockImplementation(async () => {
-				await Promise.resolve();
-				throw mockResponseError;
-			});
-
-			const { addUserHiddenDappId } = await createBackendCanister({
-				serviceOverride: service
+		it('should handle other unexpected errors', async () => {
+			service.create_pow_challenge.mockResolvedValue({
+				Err: { Other: 'Unexpected error occurred.' }
 			});
 
-			const res = addUserHiddenDappId({ dappId: 'test-dapp-id' });
+			await expect(backendCanister.createPowChallenge()).rejects.toThrowError(
+				'Unexpected error occurred.'
+			);
 
-			await expect(res).rejects.toThrow(mockResponseError);
+			expect(service.create_pow_challenge).toHaveBeenCalled();
 		});
 	});
 
diff --git a/src/frontend/src/tests/lib/services/loader.services.spec.ts b/src/frontend/src/tests/lib/services/loader.services.spec.ts
index a530ead78..3e12f8a64 100644
--- a/src/frontend/src/tests/lib/services/loader.services.spec.ts
+++ b/src/frontend/src/tests/lib/services/loader.services.spec.ts
@@ -45,7 +45,8 @@ describe('loader.services', () => {
 				}
 			});
 
-			vi.spyOn(window.history, 'replaceState').mockImplementation(() => {});
+			vi.spyOn(window.history, 'replaceState').mockImplementation(() => {
+			});
 		});
 
 		it('should return success', async () => {
@@ -157,7 +158,7 @@ describe('loader.services', () => {
 			await initLoader(mockParams);
 
 			expect(allowSigning).toHaveBeenCalledOnce();
-			expect(allowSigning).toHaveBeenNthCalledWith(1, { identity: mockIdentity });
+			expect(allowSigning).toHaveBeenNthCalledWith(1, { identity: mockIdentity, nonce: [] });
 
 			expect(loadAddresses).toHaveBeenCalledOnce();
 			expect(loadAddresses).toHaveBeenNthCalledWith(1, [ICP_NETWORK_ID, SOLANA_MAINNET_NETWORK_ID]);
diff --git a/src/frontend/src/tests/lib/utils/crypto.utils.spec.ts b/src/frontend/src/tests/lib/utils/crypto.utils.spec.ts
new file mode 100644
index 000000000..7b7e375fd
--- /dev/null
+++ b/src/frontend/src/tests/lib/utils/crypto.utils.spec.ts
@@ -0,0 +1,24 @@
+import { bufferToHex, hashToHex } from '$lib/utils/crypto.utils';
+import { describe, expect, it } from 'vitest';
+
+describe('crypto.utils', () => {
+	describe('bufferToHex', () => {
+		it('should convert an ArrayBuffer to a hexadecimal string', () => {
+			const buffer = new Uint8Array([1, 255, 16, 32]).buffer;
+			const hex = bufferToHex(buffer);
+
+			expect(hex).toBe('01ff1020');
+		});
+	});
+
+	describe('hashToHex', () => {
+		it('should hash a string and return its hex representation', async () => {
+			const input = 'hash-to-hex-test';
+			const hex = await hashToHex(input);
+
+			expect(typeof hex).toBe('string');
+
+			expect(hex.length).toBe(64);
+		});
+	});
+});
diff --git a/src/shared/src/types/pow.rs b/src/shared/src/types/pow.rs
index b0a81fcc5..c592f0fd5 100644
--- a/src/shared/src/types/pow.rs
+++ b/src/shared/src/types/pow.rs
@@ -17,11 +17,11 @@ pub const TARGET_DURATION_MS: u64 = 3000;
 
 // The challenge expires after this time (in milliseconds). Multiplying
 // `TARGET_DURATION_MS` by 4 ensures challenges remain valid longer than the targeted solve time.
-pub const EXPIRY_DURATION_MS: u64 = TARGET_DURATION_MS * 4;
+pub const EXPIRY_DURATION_MS: u64 = 120_000;
 
 // The default starting difficulty for the first PoW challenge.
 // Must lie between `MIN_DIFFICULTY` and `MAX_DIFFICULTY`.
-pub const START_DIFFICULTY: u32 = 100_000;
+pub const START_DIFFICULTY: u32 = 700_000;
 
 // The minimum allowed difficulty. Auto-adjustment will not reduce difficulty below this value.
 // Restricting difficulty may cause actual solving times to deviate from `TARGET_DURATION_MS`.
@@ -32,7 +32,7 @@ pub const MIN_DIFFICULTY: u32 = 100_000;
 pub const MAX_DIFFICULTY: u32 = 5_000_000;
 
 // The number of cycles granted per difficulty unit for signer operations.
-pub const CYCLES_PER_DIFFICULTY: u64 = 10_000;
+pub const CYCLES_PER_DIFFICULTY: u64 = 1_000_000;
 // ---------------------------------------------------------------------------------------------
 // - Error-structures and -enums
 // ---------------------------------------------------------------------------------------------
